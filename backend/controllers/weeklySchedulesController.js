/**
 * ContrÃ´leur pour la gestion des plannings hebdomadaires
 */

const db = require("../db");
const moment = require("moment");
const WeeklySchedule = require("../models/WeeklySchedule");

/**
 * CrÃ©e un nouveau planning hebdomadaire
 * @param {Object} req - RequÃªte Express
 * @param {Object} res - RÃ©ponse Express
 */
exports.createSchedule = async (req, res) => {
  try {
    const { employee_id, week_start, schedule_data, total_hours, status } =
      req.body;

    // Valider les donnÃ©es obligatoires
    if (!employee_id || !week_start) {
      return res.status(400).json({
        success: false,
        message: "ID employÃ© et date de dÃ©but de semaine requis",
      });
    }

    // Log des donnÃ©es reÃ§ues
    console.log("ðŸ§ª Planning reÃ§u (backend):", {
      employee_id,
      week_start,
      total_hours,
      schedule_data,
    });

    // Convertir schedule_data en JSON stringifiÃ© si ce n'est pas dÃ©jÃ  le cas
    const scheduleDataString =
      typeof schedule_data === "string"
        ? schedule_data
        : JSON.stringify(schedule_data);

    // CrÃ©er l'objet de planning
    const scheduleObj = new WeeklySchedule({
      employee_id,
      week_start,
      schedule_data: scheduleDataString,
      total_hours: total_hours || 0,
      status: status || "draft",
      created_by: req.user ? req.user.id : null,
    });

    // Sauvegarder le planning
    const result = await scheduleObj.save();

    // Si l'opÃ©ration a Ã©chouÃ©, renvoyer l'erreur
    if (!result.success) {
      return res.status(400).json(result);
    }

    // RÃ©cupÃ©rer l'ID du planning (qu'il soit nouvellement crÃ©Ã© ou mis Ã  jour)
    const scheduleId = result.id;

    // RÃ©cupÃ©rer les informations de l'employÃ©
    const [employeeResult] = await db.query(
      "SELECT first_name, last_name FROM employees WHERE id = ?",
      [employee_id]
    );

    // Enregistrer l'activitÃ©
    if (req.user && req.user.id) {
      try {
        const Activity = require("../models/Activity");
        const Notification = require("../models/Notification");

        // DÃ©tails de l'employÃ© pour le message
        const employeeName =
          employeeResult.length > 0
            ? `${employeeResult[0].first_name} ${employeeResult[0].last_name}`
            : `EmployÃ© #${employee_id}`;

        // Type d'activitÃ© (crÃ©ation ou mise Ã  jour)
        const activityType = result.isUpdate ? "update" : "create";

        // Description de l'activitÃ©
        const description = result.isUpdate
          ? `Mise Ã  jour d'un planning pour ${employeeName} (semaine du ${week_start})`
          : `CrÃ©ation d'un planning pour ${employeeName} (semaine du ${week_start})`;

        // Log de l'activitÃ©
        await Activity.logActivity({
          type: activityType,
          entity_type: "schedule",
          entity_id: scheduleId,
          description,
          user_id: req.user.id,
        });

        // CrÃ©er une notification pour les administrateurs et managers
        const [managers] = await db.query(
          "SELECT id FROM users WHERE role IN ('admin', 'manager')"
        );

        // Titre de la notification
        const notificationTitle = result.isUpdate
          ? "Planning modifiÃ©"
          : "Nouveau planning crÃ©Ã©";

        // Message de la notification
        const notificationMessage = result.isUpdate
          ? `Le planning de ${employeeName} (semaine du ${week_start}) a Ã©tÃ© modifiÃ©`
          : `Un planning a Ã©tÃ© crÃ©Ã© pour ${employeeName} (semaine du ${week_start})`;

        // Notifier chaque manager/admin
        for (const manager of managers) {
          // Ne pas notifier l'utilisateur qui a fait la modification
          if (manager.id !== req.user.id) {
            await Notification.createAndBroadcast({
              user_id: manager.id,
              title: notificationTitle,
              message: notificationMessage,
              type: "info",
              entity_type: "schedule",
              entity_id: scheduleId,
              link: `/weekly-schedule/${week_start}`,
            });
          }
        }
      } catch (activityError) {
        console.error(
          "Erreur lors de l'enregistrement de l'activitÃ© ou de la notification:",
          activityError
        );
      }
    }

    // DÃ©terminer le code de statut (201 pour crÃ©ation, 200 pour mise Ã  jour)
    const statusCode = result.isUpdate ? 200 : 201;

    return res.status(statusCode).json({
      success: true,
      message: result.message || "OpÃ©ration sur le planning rÃ©ussie",
      schedule: result.schedule,
    });
  } catch (error) {
    console.error("Erreur lors de la crÃ©ation du planning:", error);
    return res.status(500).json({
      success: false,
      message: "Erreur lors de la crÃ©ation du planning",
      error: error.message,
    });
  }
};

/**
 * RÃ©cupÃ¨re tous les plannings d'une semaine spÃ©cifiÃ©e
 * @param {Object} req - RequÃªte Express
 * @param {Object} res - RÃ©ponse Express
 */
exports.getSchedulesByWeek = async (req, res) => {
  try {
    const { weekStart } = req.params;
    const { status } = req.query;

    // VÃ©rifier la validitÃ© de la date
    if (!moment(weekStart, "YYYY-MM-DD", true).isValid()) {
      return res.status(400).json({
        success: false,
        message: "Format de date invalide. Utilisez YYYY-MM-DD",
      });
    }

    // Construire la requÃªte SQL de base
    let query = `
      SELECT ws.*, e.first_name, e.last_name, e.role
      FROM weekly_schedules ws
      JOIN employees e ON ws.employee_id = e.id
      WHERE ws.week_start = ?
    `;

    const queryParams = [weekStart];

    // Ajouter le filtre de statut si prÃ©sent
    if (status) {
      query += " AND ws.status = ?";
      queryParams.push(status);
    }

    // Ajouter le tri
    query += " ORDER BY ws.employee_id";

    // ExÃ©cuter la requÃªte
    const [schedules] = await db.query(query, queryParams);

    // Traiter les donnÃ©es pour avoir des objets JSON au lieu de chaÃ®nes
    const formattedSchedules = schedules.map((schedule) => {
      if (
        schedule.schedule_data &&
        typeof schedule.schedule_data === "string"
      ) {
        try {
          schedule.schedule_data = JSON.parse(schedule.schedule_data);
        } catch (error) {
          console.error("Erreur de parsing JSON pour schedule_data:", error);
        }
      }
      return schedule;
    });

    return res.status(200).json({
      success: true,
      data: formattedSchedules,
    });
  } catch (error) {
    console.error(
      "Erreur lors de la rÃ©cupÃ©ration des plannings hebdomadaires:",
      error
    );
    return res.status(500).json({
      success: false,
      message: "Erreur lors de la rÃ©cupÃ©ration des plannings",
      error: error.message,
    });
  }
};

/**
 * Met Ã  jour un planning hebdomadaire existant
 * @param {Object} req - RequÃªte Express
 * @param {Object} res - RÃ©ponse Express
 */
exports.updateSchedule = async (req, res) => {
  try {
    const { id } = req.params;
    const { employee_id, week_start, schedule_data, total_hours, status } =
      req.body;

    // Valider les donnÃ©es
    if (!id || isNaN(parseInt(id))) {
      return res.status(400).json({
        success: false,
        message: "ID de planning invalide",
      });
    }

    // Valider le statut si prÃ©sent
    if (status && !["draft", "approved"].includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Statut invalide. Utilisez "draft" ou "approved"',
      });
    }

    // VÃ©rifier si le planning existe
    const [scheduleExists] = await db.query(
      "SELECT id, employee_id, week_start FROM weekly_schedules WHERE id = ?",
      [id]
    );

    if (scheduleExists.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Planning non trouvÃ©",
      });
    }

    // PrÃ©parer les champs Ã  mettre Ã  jour
    const updateFields = [];
    const updateValues = [];

    // Ajouter l'employÃ© si fourni
    if (employee_id) {
      updateFields.push("employee_id = ?");
      updateValues.push(employee_id);
    }

    // Ajouter la date de dÃ©but si fournie
    if (week_start) {
      updateFields.push("week_start = ?");
      updateValues.push(week_start);
    }

    if (schedule_data) {
      // Convertir en chaÃ®ne JSON si ce n'est pas dÃ©jÃ  le cas
      const scheduleDataString =
        typeof schedule_data === "string"
          ? schedule_data
          : JSON.stringify(schedule_data);

      updateFields.push("schedule_data = ?");
      updateValues.push(scheduleDataString);
    }

    if (total_hours !== undefined) {
      updateFields.push("total_hours = ?");
      updateValues.push(total_hours);
    }

    if (status) {
      updateFields.push("status = ?");
      updateValues.push(status);
    }

    // Ajouter la date de mise Ã  jour
    updateFields.push("updated_at = NOW()");

    // Ajout du champ updated_by s'il y a un utilisateur connectÃ©
    if (req.user && req.user.id) {
      updateFields.push("updated_by = ?");
      updateValues.push(req.user.id);
    }

    // VÃ©rifier s'il y a des champs Ã  mettre Ã  jour
    if (updateFields.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Aucun champ Ã  mettre Ã  jour",
      });
    }

    // Construire la requÃªte SQL
    const query = `
      UPDATE weekly_schedules
      SET ${updateFields.join(", ")}
      WHERE id = ?
    `;

    // Ajouter l'ID Ã  la fin des valeurs
    updateValues.push(id);

    // ExÃ©cuter la requÃªte
    await db.query(query, updateValues);

    // RÃ©cupÃ©rer le planning mis Ã  jour pour le renvoyer dans la rÃ©ponse
    const [updatedSchedule] = await db.query(
      "SELECT * FROM weekly_schedules WHERE id = ?",
      [id]
    );

    // Formater le schedule_data si c'est une chaÃ®ne JSON
    if (
      updatedSchedule.length > 0 &&
      updatedSchedule[0].schedule_data &&
      typeof updatedSchedule[0].schedule_data === "string"
    ) {
      try {
        updatedSchedule[0].schedule_data = JSON.parse(
          updatedSchedule[0].schedule_data
        );
      } catch (error) {
        console.error("Erreur lors du parsing des donnÃ©es de planning:", error);
      }
    }

    // RÃ©cupÃ©rer les informations de l'employÃ©
    const employeeId = employee_id || scheduleExists[0].employee_id;
    const [employeeResult] = await db.query(
      "SELECT first_name, last_name FROM employees WHERE id = ?",
      [employeeId]
    );

    // Enregistrer l'activitÃ© et crÃ©er une notification
    if (req.user && req.user.id) {
      try {
        const Activity = require("../models/Activity");
        const Notification = require("../models/Notification");

        // DÃ©tails de l'employÃ© pour le message
        const employeeName =
          employeeResult.length > 0
            ? `${employeeResult[0].first_name} ${employeeResult[0].last_name}`
            : `EmployÃ© #${employeeId}`;

        const weekStartFormatted = week_start || scheduleExists[0].week_start;

        // Log de l'activitÃ©
        await Activity.logActivity({
          type: "update",
          entity_type: "schedule",
          entity_id: id,
          description: `Modification du planning de ${employeeName} (semaine du ${weekStartFormatted})`,
          user_id: req.user.id,
        });

        // CrÃ©er une notification pour le propriÃ©taire du planning et les administrateurs
        const [managers] = await db.query(
          "SELECT id FROM users WHERE role IN ('admin', 'manager') OR id = ?",
          [employeeId]
        );

        // Notifier chaque personne concernÃ©e
        for (const manager of managers) {
          // Ne pas notifier l'utilisateur qui a fait la modification
          if (manager.id !== req.user.id) {
            await Notification.createAndBroadcast({
              user_id: manager.id,
              title: "Planning modifiÃ©",
              message: `Le planning de ${employeeName} (semaine du ${weekStartFormatted}) a Ã©tÃ© modifiÃ©`,
              type: "info",
              entity_type: "schedule",
              entity_id: id,
              link: `/weekly-schedule/${weekStartFormatted}`,
            });
          }
        }
      } catch (activityError) {
        console.error(
          "Erreur lors de l'enregistrement de l'activitÃ© ou de la notification:",
          activityError
        );
      }
    }

    return res.status(200).json({
      success: true,
      message: "Planning mis Ã  jour",
      schedule: updatedSchedule.length > 0 ? updatedSchedule[0] : null,
    });
  } catch (error) {
    console.error("Erreur lors de la mise Ã  jour du planning:", error);
    return res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la mise Ã  jour du planning",
      error: error.message,
    });
  }
};

/**
 * Supprime un planning hebdomadaire existant
 * @param {Request} req - RequÃªte HTTP
 * @param {Response} res - RÃ©ponse HTTP
 * @returns {Promise<Response>} RÃ©ponse HTTP
 */
exports.deleteSchedule = async (req, res) => {
  try {
    const { id } = req.params;

    // Valider l'ID
    if (!id || isNaN(parseInt(id))) {
      return res.status(400).json({
        success: false,
        message: "ID de planning invalide",
      });
    }

    // VÃ©rifier si le planning existe
    const [scheduleExists] = await db.query(
      "SELECT id FROM weekly_schedules WHERE id = ?",
      [id]
    );

    if (scheduleExists.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Planning non trouvÃ©",
      });
    }

    // Supprimer le planning
    await db.query("DELETE FROM weekly_schedules WHERE id = ?", [id]);

    // Enregistrer l'activitÃ©
    if (req.user && req.user.id) {
      try {
        const Activity = require("../models/Activity");
        await Activity.logActivity({
          type: "delete",
          entity_type: "schedule",
          entity_id: id,
          description: "Suppression d'un planning",
          user_id: req.user.id,
        });
      } catch (activityError) {
        console.error(
          "Erreur lors de l'enregistrement de l'activitÃ© de suppression:",
          activityError
        );
      }
    }

    return res.status(200).json({
      success: true,
      message: "Planning supprimÃ© avec succÃ¨s",
    });
  } catch (error) {
    console.error("Erreur lors de la suppression du planning:", error);
    return res.status(500).json({
      success: false,
      message: "Erreur lors de la suppression",
      error: error.message,
    });
  }
};
