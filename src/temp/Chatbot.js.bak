import Lottie from "lottie-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { FaPaperPlane, FaTimes } from "react-icons/fa";
import { useLocation } from "react-router-dom";
import styled, { css, keyframes } from "styled-components";
import robotAnimation from "../../assets/animations/robot.json";
import { useAuth } from "../../contexts/AuthContext";
import ChatbotService from "../../services/chatbot-api";
import {
  createScheduleGenerationTree,
  formatScheduleStats,
  generateScheduleSummary,
  validateStepInput,
} from "../../utils/dialogTreeUtils";
import { detectIntent } from "../../utils/nlp";
import ChatbotNlpIntegration from "./ChatbotNlpIntegration";
import ScheduleValidationModalWrapper from "./ScheduleValidationModal";

// Animations
const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

const pulse = keyframes`
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
`;

const slideIn = keyframes`
  from {
    transform: translateY(30px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
`;

const slideUp = keyframes`
  from { transform: translateY(100%); }
  to { transform: translateY(0); }
`;

const buttonPop = keyframes`
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
`;

// Animations d√©finies mais non utilis√©es - comment√©es pour √©viter les avertissements ESLint
// const fadeInUp = keyframes`
//   from { opacity: 0; transform: translateY(10px); }
//   to { opacity: 1; transform: translateY(0); }
// `;

const fadeInRight = keyframes`
  from { opacity: 0; transform: translateX(10px); }
  to { opacity: 1; transform: translateX(0); }
`;

const fadeInLeft = keyframes`
  from { opacity: 0; transform: translateX(-10px); }
  to { opacity: 1; transform: translateX(0); }
`;

const typing = keyframes`
  0% { width: 0 }
  100% { width: 100% }
`;

// const blinkCaret = keyframes`
//   from, to { border-color: transparent }
//   50% { border-color: #2b5797 }
// `;

const shimmer = keyframes`
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: 200px 0;
  }
`;

const float = keyframes`
  0% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0px); }
`;

const glow = keyframes`
  0% { box-shadow: 0 0 5px rgba(99, 102, 241, 0.5); }
  50% { box-shadow: 0 0 20px rgba(99, 102, 241, 0.8); }
  100% { box-shadow: 0 0 5px rgba(99, 102, 241, 0.5); }
`;

// Composants stylis√©s
const ChatbotContainer = styled.div`
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
`;

const RobotButton = styled.button`
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background-color: ${({ theme }) => theme.colors.primary};
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  transition: all 0.3s ease;
  position: relative;
  animation: ${pulse} 2s infinite ease-in-out;
  opacity: 0.9;

  &:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    opacity: 1;
  }
`;

const WelcomeMessage = styled.div`
  position: absolute;
  top: -60px;
  right: 0;
  background-color: white;
  padding: 10px 15px;
  border-radius: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  font-size: 14px;
  max-width: 200px;
  animation: ${fadeIn} 0.5s ease-out;

  &:after {
    content: "";
    position: absolute;
    bottom: -8px;
    right: 25px;
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid white;
  }
`;

const ChatWindow = styled.div`
  position: absolute;
  bottom: 85px;
  right: 0;
  width: 350px;
  height: 450px;
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: ${slideIn} 0.3s ease-out;
  backdrop-filter: blur(10px);
  background-color: rgba(255, 255, 255, 0.95);

  @media (max-width: 576px) {
    width: 90vw;
    height: 70vh;
    bottom: 85px;
    right: 0;
    animation: ${slideUp} 0.3s ease-out;
  }
`;

const ChatHeader = styled.div`
  background-color: ${({ theme }) => theme.colors.primary};
  color: white;
  padding: 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
`;

const ChatTitle = styled.h3`
  margin: 0;
  font-size: 16px;
  display: flex;
  align-items: center;
  gap: 10px;
`;

const ModeToggleContainer = styled.div`
  display: flex;
  gap: 5px;
  margin-left: auto;
  margin-right: 10px;
`;

const ModeButton = styled.button`
  background: ${({ active, theme, mode }) =>
    active
      ? mode === "personalized"
        ? "rgba(99, 179, 237, 0.5)"
        : mode === "agent"
        ? "rgba(237, 137, 99, 0.5)"
        : "rgba(255, 255, 255, 0.3)"
      : "rgba(255, 255, 255, 0.15)"};
  border: none;
  color: white;
  padding: 5px 8px;
  font-size: 0.8rem;
  border-radius: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  transition: all 0.2s ease;
  box-shadow: ${({ active }) =>
    active ? "0 2px 4px rgba(0, 0, 0, 0.2)" : "none"};

  &:hover {
    background: ${({ mode }) =>
      mode === "personalized"
        ? "rgba(99, 179, 237, 0.7)"
        : mode === "agent"
        ? "rgba(237, 137, 99, 0.7)"
        : "rgba(255, 255, 255, 0.4)"};
    transform: translateY(-2px);
  }

  &:active {
    transform: translateY(1px);
  }

  ${({ active }) =>
    active &&
    css`
      animation: ${buttonPop} 0.3s ease;
    `}
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 5px;
  border-radius: 50%;
  transition: background-color 0.2s;

  &:hover {
    background-color: rgba(255, 255, 255, 0.2);
  }
`;

const ChatMessages = styled.div`
  flex: 1;
  padding: 15px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
`;

const Message = styled.div`
  max-width: 80%;
  padding: 12px 16px;
  border-radius: 18px;
  margin-bottom: 8px;
  white-space: pre-line;
  font-weight: 400;
  position: relative;
  line-height: 1.4;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  ${({ isUser, theme, personalized, agent }) =>
    isUser
      ? css`
          align-self: flex-end;
          background-color: ${theme.colors.primary};
          color: white;
          border-bottom-right-radius: 5px;
          animation: ${fadeInRight} 0.3s ease-out;
        `
      : css`
          align-self: flex-start;
          background: ${personalized
            ? "linear-gradient(135deg, #3a8bc7 0%, #2b77a7 100%)"
            : agent
            ? "linear-gradient(135deg, #e67e22 0%, #d35400 100%)"
            : "linear-gradient(135deg, #3a6fc7 0%, #2b5797 100%)"};
          color: white;
          border-bottom-left-radius: 5px;
          animation: ${fadeInLeft} 0.3s ease-out;

          ${personalized &&
          `
            border-left: 3px solid #90cdf4;
          `}

          ${agent &&
          `
            border-left: 3px solid #f6ad55;
          `}
        `}
`;

const ChatInputContainer = styled.form`
  display: flex;
  padding: 10px;
  border-top: 1px solid ${({ theme }) => theme.colors.border.light};
  background-color: ${({ theme }) => theme.colors.background.primary};
`;

const ChatInput = styled.input`
  flex: 1;
  padding: 10px 15px;
  border: 1px solid ${({ theme }) => theme.colors.border.main};
  border-radius: 20px;
  font-size: 14px;
  outline: none;
  transition: border-color 0.2s;

  &:focus {
    border-color: ${({ theme }) => theme.colors.primary};
  }
`;

const SendButton = styled.button`
  background-color: ${({ theme }) => theme.colors.primary};
  color: white;
  border: none;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  margin-left: 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;

  &:hover {
    background-color: ${({ theme }) => theme.colors.primary.dark};
    transform: scale(1.05);
  }

  &:disabled {
    background-color: ${({ theme }) => theme.colors.border.main};
    cursor: not-allowed;
  }
`;

// Composant non utilis√© - comment√© pour √©viter les avertissements ESLint
// const SettingsButton = styled.button`
//   background: none;
//   border: none;
//   color: white;
//   cursor: pointer;
//   margin-right: 10px;
//   display: flex;
//   align-items: center;
//   justify-content: center;
//   padding: 5px;
//   border-radius: 50%;
//   transition: background-color 0.2s;
//
//   &:hover {
//     background-color: rgba(255, 255, 255, 0.2);
//   }
// `;

const ToggleButton = styled.button`
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 3px 6px;
  border-radius: 10px;
  margin-left: 8px;
  transition: all 0.2s;
  background-color: ${(props) =>
    props.active ? "rgba(255, 255, 255, 0.3)" : "rgba(255, 255, 255, 0.1)"};

  &:hover {
    background-color: rgba(255, 255, 255, 0.4);
  }
`;

const ApiKeyModal = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
`;

const ApiKeyForm = styled.form`
  background-color: white;
  padding: 20px;
  border-radius: 10px;
  width: 80%;
  max-width: 300px;
  display: flex;
  flex-direction: column;
  gap: 15px;

  h3 {
    color: #2b5797;
    margin-bottom: 5px;
  }

  p {
    color: #333;
    font-weight: 500;
  }
`;

// Composant non utilis√© - comment√© pour √©viter les avertissements ESLint
// const ApiKeyInput = styled.input`
//   padding: 10px;
//   border: 1px solid ${({ theme }) => theme.colors.border.main};
//   border-radius: 5px;
//   font-size: 14px;
//   width: 100%;
// `;

const ApiKeyButton = styled.button`
  background-color: ${({ theme }) => theme.colors.primary};
  color: white;
  border: none;
  padding: 10px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;

  &:hover {
    background-color: ${({ theme }) => theme.colors.primary.dark};
  }
`;

// Composant non utilis√© - comment√© pour √©viter les avertissements ESLint
// const EmojiWrapper = styled.span`
//   display: inline-block;
//   margin: 0 2px;
//   animation: ${pulse} 1s infinite ease-in-out;
// `;

const HelpBubble = styled.div`
  position: absolute;
  top: -60px;
  right: 0;
  background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
  color: white;
  padding: 10px 15px;
  border-radius: 20px;
  box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
  font-size: 16px;
  font-weight: 500;
  max-width: 200px;
  z-index: 1001;
  animation: ${fadeIn} 0.5s ease-out, ${float} 3s infinite ease-in-out,
    ${glow} 2s infinite;
  display: ${({ $show }) => ($show ? "block" : "none")};
  text-align: center;

  &:after {
    content: "";
    position: absolute;
    bottom: -10px;
    right: 30px;
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 10px solid #4f46e5;
  }
`;

// Ajout de nouveaux composants stylis√©s pour l'affichage des actions
const ActionButton = styled.button`
  background-color: ${({ theme }) => theme.colors.primary};
  color: white;
  border: none;
  border-radius: ${({ theme }) => theme.borderRadius.small};
  padding: 8px 12px;
  margin-top: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background-color 0.2s;
  animation: ${fadeIn} 0.3s ease-out;

  &:hover {
    background-color: ${({ theme }) => `${theme.colors.primary}dd`};
  }

  &:disabled {
    background-color: ${({ theme }) => theme.colors.border};
    cursor: not-allowed;
  }
`;

const ActionResult = styled.div`
  background-color: ${({ $success, theme }) =>
    $success ? `${theme.colors.success}22` : `${theme.colors.error}22`};
  border: 1px solid
    ${({ $success, theme }) =>
      $success ? theme.colors.success : theme.colors.error};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  padding: 10px;
  margin-top: 8px;
  font-size: 0.9rem;
  animation: ${fadeIn} 0.3s ease-out;
`;

const ActionCard = styled.div`
  background-color: rgba(0, 0, 0, 0.05);
  border-radius: ${({ theme }) => theme.borderRadius.small};
  padding: 12px;
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  animation: ${fadeIn} 0.3s ease-out;
`;

const ActionTitle = styled.div`
  font-weight: 500;
  font-size: 0.95rem;
`;

const ActionDetail = styled.div`
  font-size: 0.85rem;
  display: flex;
  justify-content: space-between;

  & > span:first-child {
    color: ${({ theme }) => theme.colors.text.secondary};
  }
`;

const ActionsContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
`;

const getActionTitle = (intent) => {
  switch (intent) {
    case "GENERATE_SCHEDULE":
      return "G√©n√©ration de planning";
    case "VIEW_SCHEDULE":
      return "Consultation de planning";
    case "CHECK_VACATION_AVAILABILITY":
      return "V√©rification de disponibilit√© pour cong√©s";
    case "CREATE_VACATION_REQUEST":
      return "Cr√©ation de demande de cong√©s";
    case "GET_STATS":
      return "Statistiques";
    case "GET_OPTIMAL_SCHEDULE":
      return "Suggestions d'horaires optimaux";
    default:
      return "Action";
  }
};

const ToggleIcon = styled.span`
  font-size: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
`;

const ConsentModal = ({ onAccept, onDecline }) => {
  return (
    <ApiKeyModal>
      <ApiKeyForm onSubmit={(e) => e.preventDefault()}>
        <h3>Consentement RGPD</h3>
        <p
          style={{
            fontSize: "14px",
            lineHeight: "1.5",
            color: "#333",
            fontWeight: "500",
            marginBottom: "10px",
          }}
        >
          Pour vous fournir des r√©ponses personnalis√©es, l'assistant peut
          acc√©der √† certaines de vos donn√©es personnelles:
        </p>
        <ul
          style={{
            fontSize: "13px",
            lineHeight: "1.4",
            color: "#4A5568",
            marginBottom: "15px",
            paddingLeft: "20px",
          }}
        >
          <li>Informations de profil (nom, pr√©nom, email, r√¥le)</li>
          <li>Pr√©f√©rences horaires et jours de repos</li>
          <li>Historique des cong√©s et absences</li>
          <li>Plannings et horaires de travail</li>
        </ul>
        <p
          style={{
            fontSize: "14px",
            lineHeight: "1.5",
            color: "#333",
            fontWeight: "500",
            marginBottom: "5px",
          }}
        >
          Ces informations seront utilis√©es uniquement pour :
        </p>
        <ul
          style={{
            fontSize: "13px",
            lineHeight: "1.4",
            color: "#4A5568",
            marginBottom: "15px",
            paddingLeft: "20px",
          }}
        >
          <li>Personnaliser vos interactions avec l'assistant</li>
          <li>G√©n√©rer des plannings adapt√©s √† vos contraintes</li>
          <li>Vous informer sur votre planning et vos cong√©s</li>
        </ul>
        <p
          style={{
            fontSize: "14px",
            lineHeight: "1.5",
            color: "#333",
            fontWeight: "500",
          }}
        >
          Conform√©ment au RGPD, nous avons besoin de votre consentement
          explicite. Vous pouvez le retirer √† tout moment en d√©sactivant le mode
          personnalis√©.
        </p>
        <div style={{ display: "flex", gap: "10px", marginTop: "15px" }}>
          <ApiKeyButton
            type="button"
            onClick={onDecline}
            style={{ backgroundColor: "#6c757d" }}
          >
            Refuser
          </ApiKeyButton>
          <ApiKeyButton
            type="button"
            onClick={onAccept}
            style={{ backgroundColor: "#2b5797" }}
          >
            Accepter
          </ApiKeyButton>
        </div>
      </ApiKeyForm>
    </ApiKeyModal>
  );
};

// Ajouter un badge pour indiquer le mode actif
const ModeBadge = styled.div`
  position: absolute;
  top: -8px;
  left: 10px;
  background: ${({ mode }) =>
    mode === "personalized"
      ? "rgba(99, 179, 237, 0.9)"
      : "rgba(237, 137, 99, 0.9)"};
  color: white;
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 2;
  display: flex;
  align-items: center;
  gap: 3px;
`;

// Style pour le conteneur de progression de cr√©ation de planning
const SchedulingProgressContainer = styled.div`
  background-color: rgba(255, 255, 255, 0.9);
  border-radius: 10px;
  padding: 12px;
  margin: 10px 0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border-left: 3px solid #e67e22;
`;

const ProgressTitle = styled.h4`
  margin: 0 0 8px 0;
  font-size: 0.9rem;
  color: #e67e22;
  display: flex;
  align-items: center;
  gap: 6px;
`;

const ProgressSteps = styled.div`
  display: flex;
  flex-direction: column;
  gap: 5px;
`;

const ProgressStep = styled.div`
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.8rem;
  color: ${({ completed, active }) =>
    completed ? "#2ecc71" : active ? "#e67e22" : "#718096"};
  opacity: ${({ completed, active }) => (completed || active ? 1 : 0.7)};
`;

const StepIndicator = styled.span`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: ${({ completed, active }) =>
    completed ? "#2ecc71" : active ? "#e67e22" : "#cbd5e0"};
  color: white;
  font-size: 0.7rem;
  font-weight: bold;
`;

const LoadingIndicator = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  margin: 0 auto;
`;

const Dot = styled.span`
  width: 8px;
  height: 8px;
  background-color: white;
  border-radius: 50%;
  display: inline-block;
  animation: ${pulse} 1.5s infinite ease-in-out;

  &:nth-child(1) {
    animation-delay: 0s;
  }

  &:nth-child(2) {
    animation-delay: 0.3s;
  }

  &:nth-child(3) {
    animation-delay: 0.6s;
  }
`;

const SpinnerAnimation = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const Spinner = styled.div`
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  border-top-color: transparent;
  animation: ${SpinnerAnimation} 1s linear infinite;
  margin: 0 auto;
`;

const Chatbot = () => {
  const { user } = useAuth();
  const location = useLocation();
  const [isOpen, setIsOpen] = useState(false);
  const [showWelcome, setShowWelcome] = useState(false);
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [showHelpBubble, setShowHelpBubble] = useState(false);
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);
  const [isLoading, setIsLoading] = useState(false);
  const [hasUserConsent, setHasUserConsent] = useState(
    localStorage.getItem("chatbot_data_consent") === "true"
  );
  const [showConsentModal, setShowConsentModal] = useState(false);
  const [apiKey] = useState("Mtj4YyKWVol6Km2iLeCCtAF4Y1nNlbbE");
  const [currentAction, setCurrentAction] = useState(null);
  const [actionResult, setActionResult] = useState(null);
  const [isActionLoading, setIsActionLoading] = useState(false);
  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);
  const [isPersonalizedMode, setIsPersonalizedMode] = useState(false);
  const [isAgentMode, setIsAgentMode] = useState(false);
  const [schedulingInProgress, setSchedulingInProgress] = useState(false);
  const [schedulingData, setSchedulingData] = useState({
    weekStart: null,
    constraints: [],
    employees: [],
    businessHours: null,
    breakTimes: null,
  });
  const [dialogTree, setDialogTree] = useState(null);
  const [dialogStep, setDialogStep] = useState(null);
  const [collectedData, setCollectedData] = useState({});
  const [isTyping, setIsTyping] = useState(false);
  const [scheduleValidationOpen, setScheduleValidationOpen] = useState(false);
  const [generatedSchedule, setGeneratedSchedule] = useState(null);

  // R√©f√©rence √† l'int√©gration NLP
  const nlpIntegration = useRef(null);

  // V√©rifier si le chatbot doit √™tre affich√© sur la page actuelle
  const shouldShowChatbot = () => {
    // Ne pas afficher sur la landing page, login ou register
    const restrictedPaths = [
      "/",
      "/login",
      "/register",
      "/forgot-password",
      "/reset-password",
    ];

    // V√©rifier si l'utilisateur est connect√© et si la page actuelle n'est pas restreinte
    return user && !restrictedPaths.includes(location.pathname);
  };

  useEffect(() => {
    if (user && !localStorage.getItem("chatbot_data_consent")) {
      setShowConsentModal(true);
    }
  }, [user]);

  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
    }
  }, [messages]);

  useEffect(() => {
    if (isOpen && inputRef.current) {
      setTimeout(() => {
        inputRef.current.focus();
      }, 300);
    }
  }, [isOpen]);

  useEffect(() => {
    if (!isOpen) {
      const initialTimeout = setTimeout(() => {
        setShowHelpBubble(true);
      }, 5000);

      const hideTimeout = setTimeout(() => {
        setShowHelpBubble(false);
      }, 12000);

      const interval = setInterval(() => {
        setShowHelpBubble(true);
        setTimeout(() => {
          setShowHelpBubble(false);
        }, 7000);
      }, 30000);

      return () => {
        clearTimeout(initialTimeout);
        clearTimeout(hideTimeout);
        clearInterval(interval);
      };
    } else {
      setShowHelpBubble(false);
    }
  }, [isOpen]);

  useEffect(() => {
    console.log("Auth context user:", user);
    if (user && !user.firstName && !user.first_name && !user.name) {
      console.log("Tentative de r√©cup√©ration des donn√©es utilisateur...");
    }
  }, [user]);

  const toggleChat = () => {
    setIsOpen(!isOpen);
    setShowWelcome(false);

    if (!isOpen && messages.length === 0) {
      setMessages([
        {
          text: `üëã Bonjour ! Je suis votre assistant virtuel. Comment puis-je vous aider aujourd'hui ?`,
          isUser: false,
        },
      ]);
    }
  };

  const localResponses = {
    bonjour:
      "Bonjour ! Comment puis-je vous aider avec la gestion de votre planning ?",
    salut:
      "Salut ! Je suis l√† pour vous aider avec Smart Planning. Que souhaitez-vous faire ?",
    aide: "Je peux vous aider avec plusieurs fonctionnalit√©s de Smart Planning :\n- Gestion des plannings hebdomadaires\n- Gestion des employ√©s\n- Gestion des cong√©s\n- Statistiques et rapports\nQue voulez-vous savoir ?",
    planning:
      "Dans Smart Planning, vous pouvez g√©rer les plannings hebdomadaires en allant dans la section 'Planning Hebdomadaire'. Vous pourrez y affecter des horaires √† vos employ√©s, g√©rer les absences et exporter les plannings en PDF.",
    employ√©s:
      "La gestion des employ√©s se fait dans la section 'Employ√©s'. Vous pouvez y ajouter, modifier ou supprimer des employ√©s, ainsi que consulter leurs informations et historiques.",
    cong√©s:
      "Pour g√©rer les cong√©s, rendez-vous dans la section 'Cong√©s'. Vous pourrez y voir les demandes en attente, les approuver ou les refuser, et consulter le calendrier des cong√©s.",
    statistiques:
      "Les statistiques sont disponibles dans la section 'Statistiques'. Vous y trouverez des graphiques sur les heures travaill√©es, les absences, et d'autres indicateurs importants.",
    merci: "Je vous en prie ! N'h√©sitez pas si vous avez d'autres questions.",
    "au revoir":
      "Au revoir ! N'h√©sitez pas √† revenir si vous avez besoin d'aide.",
    configuration:
      "Vous pouvez configurer l'application dans la section 'Param√®tres'. Vous y trouverez les options pour personnaliser l'application selon vos besoins.",
  };

  const getLocalResponse = (query) => {
    const normalizedQuery = query.toLowerCase().trim();

    for (const [keyword, response] of Object.entries(localResponses)) {
      if (normalizedQuery.includes(keyword)) {
        return response;
      }
    }

    if (
      normalizedQuery.includes("comment") &&
      normalizedQuery.includes("ajouter") &&
      normalizedQuery.includes("employ√©")
    ) {
      return "Pour ajouter un nouvel employ√©, allez dans la section 'Employ√©s' et cliquez sur le bouton '+ Ajouter un employ√©'. Remplissez ensuite le formulaire avec les informations de l'employ√©.";
    }

    if (
      normalizedQuery.includes("comment") &&
      normalizedQuery.includes("export")
    ) {
      return "Pour exporter un planning, allez dans la section 'Planning Hebdomadaire', puis cliquez sur le bouton 'Options d'export'. Vous pourrez choisir d'exporter le planning global ou par d√©partement.";
    }

    if (
      normalizedQuery.includes("comment") &&
      normalizedQuery.includes("modifi") &&
      normalizedQuery.includes("planning")
    ) {
      return "Pour modifier un planning, allez dans la section 'Planning Hebdomadaire', trouvez l'employ√© concern√© et cliquez sur le bouton '√âditer' √† droite de son nom. Vous pourrez alors modifier ses horaires et absences.";
    }

    return "Je ne suis pas s√ªr de comprendre votre demande. Pourriez-vous reformuler ou me demander de l'aide sur la gestion des plannings, des employ√©s ou des cong√©s ?";
  };

  /**
   * R√©cup√®re les informations personnalis√©es de l'utilisateur
   * @returns {Promise<Object|null>} - Informations personnalis√©es ou null si non autoris√©
   */
  const getUserPersonalizedInfo = async () => {
    if (!hasUserConsent) {
      console.log(
        "L'utilisateur n'a pas donn√© son consentement pour acc√©der √† ses donn√©es"
      );
      return null;
    }

    // Information de base de l'utilisateur (depuis le localStorage)
    const userStr = localStorage.getItem("user");
    if (!userStr) {
      console.log("Aucun utilisateur connect√©");
      return null;
    }

    const user = JSON.parse(userStr);

    try {
      // Tentative de r√©cup√©ration des donn√©es r√©elles depuis l'API
      const employeesResult = await ChatbotService.getEmployeesWithDetails();

      if (
        employeesResult.success &&
        employeesResult.employees &&
        employeesResult.employees.length > 0
      ) {
        const formattedEmployees = employeesResult.employees;

        // Trouver l'utilisateur actuel
        const userEmail = user.email || "";
        const currentUserData = formattedEmployees.find(
          (emp) => emp.email.toLowerCase() === userEmail.toLowerCase()
        );

        // Informations de l'utilisateur actuel
        const userData = currentUserData || {
          firstName: user.firstName || user.first_name || "",
          lastName: user.lastName || user.last_name || "",
          email: user.email || "",
          role: user.role || "",
          hireDate: "",
          department: "",
          hours: 35,
          preferredDays: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi"],
        };

        return {
          nom: userData.lastName,
          prenom: userData.firstName,
          email: userData.email,
          role: userData.role,
          dateEmbauche: userData.hireDate,
          departement: userData.department,
          heures: userData.hours,
          joursPreferences: userData.preferredDays,
          equipe: formattedEmployees,
        };
      }
    } catch (error) {
      console.error(
        "Erreur lors de la r√©cup√©ration des donn√©es des employ√©s:",
        error
      );
    }

    // En cas d'√©chec, utiliser des donn√©es simul√©es comme solution de secours
    const sampleEmployeesData = [
      {
        id: 1,
        firstName: "Alex",
        lastName: "Dupont",
        email: "alex.dupont@example.com",
        role: "D√©veloppeur",
        hireDate: "2020-03-15",
        department: "IT",
        hours: 35,
        preferredDays: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi"],
      },
      {
        id: 2,
        firstName: "Marie",
        lastName: "Lambert",
        email: "marie.lambert@example.com",
        role: "Designer",
        hireDate: "2021-06-10",
        department: "Design",
        hours: 28,
        preferredDays: ["Lundi", "Mardi", "Jeudi"],
      },
      {
        id: 3,
        firstName: "Thomas",
        lastName: "Mercier",
        email: "thomas.mercier@example.com",
        role: "Chef de projet",
        hireDate: "2019-01-21",
        department: "Management",
        hours: 35,
        preferredDays: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi"],
      },
      {
        id: 4,
        firstName: "Stacy",
        lastName: "Moreau",
        email: "stacy.moreau@example.com",
        role: "Marketing",
        hireDate: "2021-02-15", // Date correcte selon la base de donn√©es
        department: "Marketing",
        hours: 35,
        preferredDays: ["Lundi", "Mardi", "Jeudi", "Vendredi"],
      },
    ];

    // Trouver les informations de l'utilisateur actuel dans nos donn√©es simul√©es
    const userEmail = user.email || "";
    const currentUserData = sampleEmployeesData.find(
      (emp) => emp.email.toLowerCase() === userEmail.toLowerCase()
    );

    // Si l'email ne correspond pas √† nos donn√©es simul√©es, utiliser les informations de base de l'utilisateur
    const userData = currentUserData || {
      firstName: user.firstName || user.first_name || "",
      lastName: user.lastName || user.last_name || "",
      email: user.email || "",
      role: user.role || "",
      hireDate: "2021-01-01", // Date par d√©faut si inconnue
      department: "Non sp√©cifi√©",
      hours: 35,
      preferredDays: ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi"],
    };

    return {
      nom: userData.lastName,
      prenom: userData.firstName,
      email: userData.email,
      role: userData.role,
      dateEmbauche: userData.hireDate,
      departement: userData.department,
      heures: userData.hours,
      joursPreferences: userData.preferredDays,
      equipe: sampleEmployeesData,
    };
  };

  const enhanceResponseWithEmojis = (response) => {
    let enhancedResponse = response
      .replace(/bonjour/i, "Bonjour üëã")
      .replace(/salut/i, "Salut üëã")
      .replace(/hello/i, "Hello üëã")
      .replace(/bonsoir/i, "Bonsoir üåô")
      .replace(/merci/i, "Merci üôè")
      .replace(/planning/i, "planning üìÖ")
      .replace(/employ√©s/i, "employ√©s üë•")
      .replace(/cong√©s/i, "cong√©s üèñÔ∏è")
      .replace(/statistiques/i, "statistiques üìä")
      .replace(/exporter/i, "exporter üì§")
      .replace(/importer/i, "importer üì•")
      .replace(/param√®tres/i, "param√®tres ‚öôÔ∏è")
      .replace(/configuration/i, "configuration üõ†Ô∏è")
      .replace(/aide/i, "aide üÜò");

    if (Math.random() > 0.7) {
      const humorousEndings = [
        "\n\nN'h√©sitez pas √† me poser d'autres questions, je suis l√† pour √ßa ! üòä",
        "\n\nJe suis √† votre service pour toute autre question. ü§ì",
        "\n\nAvez-vous besoin d'autre chose ? Je suis plus rapide qu'un agenda papier ! üìù",
        "\n\nJ'esp√®re que cette r√©ponse vous aide. Sinon, dites-le moi, je ne me vexe pas ! üòâ",
        "\n\nUne autre question ? Je suis l√†, et je ne prends jamais de pause caf√© ! ‚òï",
      ];
      enhancedResponse +=
        humorousEndings[Math.floor(Math.random() * humorousEndings.length)];
    }

    return enhancedResponse;
  };

  const processIntent = async (intent, params) => {
    setCurrentAction({ intent, params });
    setActionResult(null);
    setIsActionLoading(false);
    console.log("Intention d√©tect√©e:", intent, params);

    // Ajouter un message pour confirmer la d√©tection de l'intention
    let confirmationMessage = "";

    switch (intent) {
      case "GENERATE_SCHEDULE":
        confirmationMessage = `Je peux g√©n√©rer un planning pour la semaine du ${params.weekStart}. Voulez-vous proc√©der ?`;
        break;
      case "VIEW_SCHEDULE":
        confirmationMessage = `Je peux afficher le planning pour la semaine du ${params.weekStart}. Voulez-vous le consulter ?`;
        break;
      case "CHECK_VACATION_AVAILABILITY":
        confirmationMessage = `Je peux v√©rifier la disponibilit√© pour des cong√©s du ${params.startDate} au ${params.endDate}. Voulez-vous proc√©der ?`;
        break;
      case "CREATE_VACATION_REQUEST":
        confirmationMessage = `Je peux cr√©er une demande de cong√©s du ${params.startDate} au ${params.endDate}. Voulez-vous proc√©der ?`;
        break;
      case "GET_STATS":
        confirmationMessage = `Je peux vous montrer les statistiques pour la p√©riode : ${params.period}. Voulez-vous les consulter ?`;
        break;
      case "GET_OPTIMAL_SCHEDULE":
        confirmationMessage = `Je peux vous sugg√©rer des horaires optimaux pour la semaine du ${params.weekStart}. Voulez-vous recevoir des suggestions ?`;
        break;
      case "HELP":
        handleHelpIntent();
        return;
      case "LIST_EMPLOYEES":
        confirmationMessage = `Je peux vous afficher la liste des employ√©s. Souhaitez-vous consulter cette liste ?`;
        break;
      case "SET_REMINDER":
        confirmationMessage = `Je peux cr√©er un rappel pour le ${params.date} avec le message "${params.message}". Voulez-vous ajouter ce rappel ?`;
        break;
      case "USER_PREFERENCES":
        confirmationMessage = `Je peux vous aider √† g√©rer vos pr√©f√©rences. Souhaitez-vous les consulter ou les modifier ?`;
        break;
      case "SEARCH_INFO":
        confirmationMessage = `Je vais rechercher des informations sur "${params.query}". Est-ce bien ce que vous souhaitez ?`;
        break;
      case "FEEDBACK":
        confirmationMessage = `Je vais enregistrer votre feedback. Souhaitez-vous continuer ?`;
        break;
      default:
        confirmationMessage =
          "Je ne suis pas s√ªr de comprendre votre demande. Pouvez-vous pr√©ciser ?";
        setCurrentAction(null);
        break;
    }

    setMessages((prev) => [
      ...prev,
      {
        text: confirmationMessage,
        isUser: false,
      },
    ]);
  };

  /**
   * G√®re la simulation des r√©ponses pour les fonctionnalit√©s qui ne sont pas encore
   * impl√©ment√©es c√¥t√© backend
   * @param {string} intent - L'intention d√©tect√©e
   * @param {Object} params - Les param√®tres de l'intention
   * @returns {Object} - R√©sultat simul√©
   */
  const getMockResponse = (intent, params) => {
    // Formatage de la date pour l'affichage
    const formatDate = (dateStr) => {
      if (!dateStr) return "Non sp√©cifi√©e";
      try {
        const date = new Date(dateStr);
        return date.toLocaleDateString("fr-FR", {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric",
        });
      } catch (e) {
        return dateStr;
      }
    };

    // Liste de noms r√©alistes pour les simulations
    const sampleEmployees = [
      { id: 1, name: "Alex Dupont", role: "D√©veloppeur", hours: 35 },
      { id: 2, name: "Marie Lambert", role: "Designer", hours: 28 },
      { id: 3, name: "Thomas Mercier", role: "Chef de projet", hours: 35 },
      { id: 4, name: "Sophie Moreau", role: "Marketing", hours: 35 },
      { id: 5, name: "Julien Petit", role: "Commercial", hours: 35 },
      { id: 6, name: "Laura Bernard", role: "RH", hours: 28 },
      { id: 7, name: "Nicolas Martin", role: "Support client", hours: 35 },
    ];

    // Prendre un sous-ensemble al√©atoire d'employ√©s
    const getRandomEmployees = (count = 3) => {
      const shuffled = [...sampleEmployees].sort(() => 0.5 - Math.random());
      return shuffled.slice(0, count);
    };

    switch (intent) {
      case "GENERATE_SCHEDULE":
        // Utiliser les param√®tres fournis ou des valeurs par d√©faut
        const weekStart =
          params.weekStart || new Date().toISOString().split("T")[0];
        const businessHours =
          params.businessHours ||
          "9h-18h du lundi au vendredi, 10h-17h le samedi";
        const constraints = params.constraints || [
          "vacations",
          "rest_preferences",
        ];
        const breakTimes =
          params.breakTimes ||
          "1h pour le d√©jeuner, 15min en milieu de matin√©e et d'apr√®s-midi";

        // G√©n√©rer un planning plus d√©taill√© et r√©aliste
        const employeesForSchedule = getRandomEmployees(5);
        const days = ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi"];
        const assignments = [];

        // Cr√©er des assignations r√©alistes pour chaque employ√©
        employeesForSchedule.forEach((emp) => {
          // Chaque employ√© travaille 3 √† 5 jours par semaine selon ses heures
          const workDaysCount = emp.hours >= 35 ? 5 : emp.hours >= 28 ? 4 : 3;
          const shuffledDays = [...days].sort(() => 0.5 - Math.random());
          const workDays = shuffledDays.slice(0, workDaysCount);

          workDays.forEach((day) => {
            // Horaires diff√©rents selon les jours et les employ√©s
            let startHour, endHour;

            if (day === "Lundi" || day === "Vendredi") {
              // Horaires variables pour ces jours
              startHour = Math.random() > 0.5 ? "09:00" : "10:00";
              const hoursPerDay = emp.hours / workDaysCount;
              endHour =
                startHour === "09:00"
                  ? hoursPerDay >= 8
                    ? "18:00"
                    : "17:00"
                  : hoursPerDay >= 8
                  ? "19:00"
                  : "18:00";
            } else {
              // Horaires standards pour les autres jours
              startHour = "09:00";
              endHour = emp.hours >= 35 ? "18:00" : "17:00";
            }

            assignments.push({
              employeeId: emp.id,
              employeeName: emp.name,
              day: day,
              start: startHour,
              end: endHour,
              breaks: ["12:00-13:00"], // Pause d√©jeuner
            });
          });
        });

        return {
          success: true,
          message: `Planning g√©n√©r√© avec succ√®s pour la semaine du ${formatDate(
            weekStart
          )}`,
          schedule: {
            weekStart: weekStart,
            employees: employeesForSchedule,
            businessHours: businessHours,
            breakTimes: breakTimes,
            constraints: constraints,
            days: days,
            totalHours: employeesForSchedule.reduce(
              (sum, emp) => sum + emp.hours,
              0
            ),
            assignments: assignments,
          },
          simulation: true,
        };
      case "CHECK_VACATION_AVAILABILITY":
        // Simuler al√©atoirement disponible ou non
        const isAvailable = Math.random() > 0.3;
        return {
          success: true,
          available: isAvailable,
          message: isAvailable
            ? `Les dates du ${formatDate(params.startDate)} au ${formatDate(
                params.endDate
              )} sont disponibles pour cong√©s`
            : `Les dates demand√©es pr√©sentent des conflits`,
          conflicts: isAvailable
            ? []
            : [
                { date: params.startDate, reason: "P√©riode charg√©e" },
                {
                  date: new Date(
                    new Date(params.startDate).getTime() + 86400000
                  )
                    .toISOString()
                    .split("T")[0],
                  reason: "Quota d'employ√©s absents atteint",
                },
              ],
          simulation: true,
        };
      case "GET_STATS":
        return {
          success: true,
          message: `Statistiques r√©cup√©r√©es pour la p√©riode : ${params.period}`,
          stats: {
            totalHours: 156,
            vacationDays: 3,
            averageHoursPerDay: 7.8,
            workDays: 20,
            otHours: 12,
            attendance: 96.5,
            period: params.period,
            departments: [
              { name: "D√©veloppement", hours: 480, employees: 3 },
              { name: "Design", hours: 320, employees: 2 },
              { name: "Marketing", hours: 280, employees: 2 },
            ],
          },
          simulation: true,
        };
      case "GET_OPTIMAL_SCHEDULE":
        return {
          success: true,
          message: "Suggestions de cr√©neaux optimaux g√©n√©r√©es",
          suggestions: [
            { day: "Lundi", start: "09:00", end: "17:00", score: 98 },
            { day: "Mardi", start: "10:00", end: "18:00", score: 92 },
            { day: "Mercredi", start: "08:00", end: "16:00", score: 85 },
            { day: "Jeudi", start: "09:00", end: "17:00", score: 90 },
            { day: "Vendredi", start: "10:00", end: "16:00", score: 88 },
          ],
          employeeId: params.employeeId,
          weekStart: params.weekStart,
          simulation: true,
        };
      case "LIST_EMPLOYEES":
        return {
          success: true,
          message: "Liste des employ√©s r√©cup√©r√©e",
          employees: sampleEmployees,
          simulation: true,
        };
      case "SEARCH_INFO":
        return {
          success: true,
          message: `R√©sultats de la recherche pour "${params.query}"`,
          results: [
            {
              title: "Informations sur les plannings",
              content: `Les plannings sont g√©n√©r√©s en tenant compte des contraintes et pr√©f√©rences des employ√©s. La recherche sur "${params.query}" a retourn√© des informations concernant les horaires de travail et la gestion des √©quipes.`,
            },
            {
              title: "R√®gles d'entreprise",
              content: `Les r√®gles d'entreprise relatives √† "${params.query}" pr√©cisent que les employ√©s doivent avoir au moins 11 heures de repos entre deux journ√©es de travail.`,
            },
          ],
          simulation: true,
        };
      case "CREATE_VACATION_REQUEST":
        return {
          success: true,
          message: `Demande de cong√©s cr√©√©e avec succ√®s pour la p√©riode du ${formatDate(
            params.startDate
          )} au ${formatDate(params.endDate)}`,
          vacationRequest: {
            id: Math.floor(Math.random() * 1000) + 100,
            employeeId: params.employeeId,
            startDate: params.startDate,
            endDate: params.endDate,
            type: params.type || "vacation",
            status: "pending",
            createdAt: new Date().toISOString(),
          },
          simulation: true,
        };
      default:
        return {
          success: true,
          message: "Action trait√©e avec succ√®s (simulation)",
          simulation: true,
        };
    }
  };

  /**
   * G√®re sp√©cifiquement l'intention d'aide
   */
  const handleHelpIntent = async () => {
    try {
      const result = await ChatbotService.getHelpInfo();

      let helpMessage = "Voici ce que je peux faire pour vous :\n\n";

      if (result.success && result.helpInfo) {
        result.helpInfo.features.forEach((feature) => {
          helpMessage += `üìå **${feature.name}**\n`;
          helpMessage += `   Exemples: "${feature.commands[0]}", "${feature.commands[1]}"\n\n`;
        });
      } else {
        helpMessage += `
üìå **Gestion des plannings**
   Je peux g√©n√©rer, afficher ou optimiser les plannings.

üìå **Gestion des cong√©s**
   Je peux v√©rifier la disponibilit√© et cr√©er des demandes de cong√©s.

üìå **Statistiques et informations**
   Je peux afficher vos statistiques et rechercher des informations.

üìå **Rappels et notifications**
   Je peux vous aider √† ne rien oublier avec des rappels personnalis√©s.
      `;
      }

      helpMessage +=
        "\nVous pouvez essayer l'une de ces commandes ou me demander plus de d√©tails sur une fonctionnalit√© sp√©cifique.";

      setMessages((prev) => [
        ...prev,
        {
          text: helpMessage,
          isUser: false,
        },
      ]);

      setCurrentAction(null);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de l'aide:", error);
      setMessages((prev) => [
        ...prev,
        {
          text: "Je ne parviens pas √† r√©cup√©rer les informations d'aide. Veuillez r√©essayer plus tard.",
          isUser: false,
        },
      ]);
    }
  };

  /**
   * G√©n√®re une r√©ponse format√©e √† partir du r√©sultat d'une action
   * @param {Object} result - Le r√©sultat de l'action
   * @param {string} intent - L'intention associ√©e √† l'action
   * @returns {string} - Message format√©
   */
  const formatActionResult = (result, intent) => {
    if (!result.success) {
      return `‚ùå ${result.message || "√âchec de l'action."}`;
    }

    // Pr√©fixe de simulation si applicable
    const simulationPrefix = result.simulation ? "[SIMULATION] " : "";

    let formattedMessage = `‚úÖ ${simulationPrefix}${
      result.message || "Action effectu√©e avec succ√®s !"
    }`;

    // Enrichir le message selon l'intention
    switch (intent) {
      case "GENERATE_SCHEDULE":
        if (result.schedule) {
          formattedMessage += `\n\nLe planning a √©t√© g√©n√©r√© pour ${
            result.schedule.employees?.length || 0
          } employ√©s sur la semaine du ${result.schedule.weekStart}.`;

          if (result.simulation) {
            formattedMessage +=
              "\n\nCeci est une simulation car l'API n'est pas disponible. Dans un environnement de production, vous pourriez consulter ce planning dans l'application.";
          }
        }
        break;
      case "CHECK_VACATION_AVAILABILITY":
        if (result.available) {
          formattedMessage +=
            "\n\nBonne nouvelle ! Ces dates sont disponibles pour poser des cong√©s. Souhaitez-vous cr√©er une demande maintenant ?";
        } else if (result.conflicts && result.conflicts.length > 0) {
          formattedMessage += `\n\nIl y a ${result.conflicts.length} conflits pour ces dates. Voulez-vous explorer d'autres options ?`;
        }

        if (result.simulation) {
          formattedMessage +=
            "\n\nNotez que cette v√©rification est une simulation.";
        }
        break;
      case "GET_STATS":
        if (result.stats) {
          formattedMessage += "\n\nVoici un r√©sum√© de vos statistiques :";
          if (result.stats.totalHours)
            formattedMessage += `\n- Total d'heures : ${result.stats.totalHours}h`;
          if (result.stats.vacationDays)
            formattedMessage += `\n- Jours de cong√©s : ${result.stats.vacationDays}`;

          if (result.simulation) {
            formattedMessage +=
              "\n\nCes donn√©es sont simul√©es √† titre d'exemple.";
          }
        }
        break;
      case "LIST_EMPLOYEES":
        if (result.employees && result.employees.length > 0) {
          formattedMessage += "\n\nListe des employ√©s :";
          result.employees.slice(0, 5).forEach((emp) => {
            formattedMessage += `\n- ${emp.name} (${emp.role || "Employ√©"})`;
          });
          if (result.employees.length > 5) {
            formattedMessage += `\n... et ${
              result.employees.length - 5
            } autres employ√©s.`;
          }

          if (result.simulation) {
            formattedMessage += "\n\nCette liste est simul√©e.";
          }
        }
        break;
    }

    formattedMessage += "\n\nPuis-je vous aider avec autre chose ?";
    return formattedMessage;
  };

  /**
   * G√®re l'erreur d'une action et g√©n√®re un message appropri√©
   * @param {Error} error - L'erreur survenue
   * @param {string} intent - L'intention associ√©e √† l'action
   * @returns {Object} - Message d'erreur format√© et informations compl√©mentaires
   */
  const handleActionError = (error, intent) => {
    console.error(`Erreur lors de l'ex√©cution de l'action ${intent}:`, error);

    // V√©rifier plus pr√©cis√©ment si c'est une erreur 404 (API non disponible)
    const is404 =
      error.status === 404 ||
      (error.message && error.message.includes("404")) ||
      (error.response && error.response.status === 404) ||
      (error.message && error.message.includes("Not Found"));

    // Si c'est une erreur 404, proposer une simulation
    if (is404) {
      // Pour GENERATE_SCHEDULE, traitement sp√©cial
      if (intent === "GENERATE_SCHEDULE") {
        return {
          text: `‚ö†Ô∏è Le service de g√©n√©ration de planning n'est pas disponible actuellement. Je peux vous proposer une simulation pour vous montrer comment cela fonctionnerait.`,
          isUser: false,
          requiresSimulation: true,
          agent: isAgentMode, // Ajouter l'indicateur de mode agent si n√©cessaire
        };
      }

      // Pour les autres intentions, comportement standard avec simulation automatique
      setTimeout(() => {
        // Activer le mode simulation avec l'intention originale
        setCurrentAction({
          intent: "SIMULATE",
          params: {
            originalIntent: intent,
            originalParams: currentAction ? currentAction.params : {},
          },
        });

        // Ex√©cuter la simulation
        executeAction();
      }, 500);

      return {
        text: `‚ö†Ô∏è Cette fonctionnalit√© n'est pas encore disponible sur le serveur. Je vous montre une simulation pour vous donner une id√©e de son fonctionnement.`,
        isUser: false,
        agent: isAgentMode, // Ajouter l'indicateur de mode agent si n√©cessaire
      };
    }

    // Messages personnalis√©s selon l'intention
    let errorMsg = `‚ùå Une erreur est survenue : ${
      error.message || "Erreur inconnue"
    }`;

    switch (intent) {
      case "GENERATE_SCHEDULE":
        errorMsg +=
          "\n\nImpossible de g√©n√©rer le planning. Vous pouvez essayer avec une autre date ou utiliser l'interface manuelle.";
        errorMsg +=
          "\n\nVoulez-vous que je vous montre une simulation de planning √† la place ?";
        return {
          text: errorMsg,
          isUser: false,
          requiresSimulation: true,
          agent: isAgentMode,
        };
      case "CHECK_VACATION_AVAILABILITY":
        errorMsg +=
          "\n\nImpossible de v√©rifier la disponibilit√©. Vous pouvez essayer avec d'autres dates ou v√©rifier directement dans la section cong√©s.";
        break;
      case "CREATE_VACATION_REQUEST":
        errorMsg +=
          "\n\nImpossible de cr√©er la demande de cong√©s. Assurez-vous que les dates sont correctes et que vous avez les droits n√©cessaires.";
        break;
      default:
        errorMsg +=
          "\n\nVeuillez r√©essayer ult√©rieurement ou utiliser l'interface classique pour cette action.";
    }

    return {
      text: errorMsg,
      isUser: false,
      agent: isAgentMode,
    };
  };

  const executeAction = async () => {
    if (!currentAction) return;

    setIsActionLoading(true);
    const { intent, params } = currentAction;

    try {
      let result = null;

      // Simulation si demand√©e explicitement
      if (intent === "SIMULATE") {
        const originalIntent = params.originalIntent;
        const originalParams = params.originalParams;

        result = getMockResponse(originalIntent, originalParams);

        // Ajouter un d√©lai pour simuler un appel API
        await new Promise((resolve) => setTimeout(resolve, 1000));

        setActionResult(result);
        setMessages((prev) => [
          ...prev,
          {
            text: "‚öôÔ∏è Mode simulation activ√© ‚öôÔ∏è",
            isUser: false,
          },
          {
            text: formatActionResult(result, originalIntent),
            isUser: false,
          },
        ]);

        setTimeout(() => {
          setCurrentAction(null);
          setActionResult(null);
        }, 5000);

        setIsActionLoading(false);
        return;
      }

      try {
        // Tenter d'ex√©cuter l'action r√©elle
        switch (intent) {
          case "GENERATE_SCHEDULE":
            try {
              result = await ChatbotService.generateSchedule(
                params.weekStart,
                params.options || {}
              );
            } catch (scheduleError) {
              // V√©rifier sp√©cifiquement si c'est une erreur 404 pour la g√©n√©ration de planning
              const is404 =
                scheduleError.message &&
                (scheduleError.message.includes("404") ||
                  scheduleError.message.includes("Not Found") ||
                  (scheduleError.response &&
                    scheduleError.response.status === 404));

              if (is404) {
                // Log explicite pour le debug
                console.log(
                  "API de g√©n√©ration de planning non disponible, utilisation de la simulation",
                  scheduleError
                );

                // Ajouter un message sp√©cifique pour cette erreur
                setMessages((prev) => [
                  ...prev,
                  {
                    text: `‚öôÔ∏è Le service de g√©n√©ration de planning n'est pas disponible actuellement. Je vous pr√©sente une simulation √† titre d'exemple.`,
                    isUser: false,
                    agent: true,
                  },
                ]);

                // Utiliser la simulation avec tous les param√®tres disponibles
                result = getMockResponse("GENERATE_SCHEDULE", {
                  weekStart: params.weekStart,
                  businessHours: params.options?.businessHours,
                  constraints: params.options?.constraints || [
                    "vacations",
                    "rest_preferences",
                  ],
                  breakTimes: params.options?.breakTimes,
                });
                result.simulation = true;
              } else {
                // Pour les autres erreurs, relancer pour le traitement standard
                throw scheduleError;
              }
            }
            break;
          case "VIEW_SCHEDULE":
            // Rediriger vers la page de planning avec les param√®tres appropri√©s
            window.location.href = `/weekly-schedule/${params.weekStart}`;
            result = {
              success: true,
              message: "Redirection vers la page de planning...",
            };
            break;
          case "CHECK_VACATION_AVAILABILITY":
            result = await ChatbotService.checkVacationAvailability(
              params.employeeId,
              params.startDate,
              params.endDate
            );
            break;
          case "CREATE_VACATION_REQUEST":
            result = await ChatbotService.createVacationRequest({
              employee_id: params.employeeId,
              start_date: params.startDate,
              end_date: params.endDate,
              type: params.type || "vacation",
              status: "pending",
              comments: "Cr√©√© via l'assistant IA",
            });
            break;
          case "GET_STATS":
            result = await ChatbotService.getEmployeeStats(
              params.employeeId,
              params.period
            );
            break;
          case "GET_OPTIMAL_SCHEDULE":
            result = await ChatbotService.getOptimalScheduleSuggestion(
              params.employeeId,
              params.weekStart
            );
            break;
          case "LIST_EMPLOYEES":
            result = await ChatbotService.getEmployeesList();
            break;
          case "SET_REMINDER":
            result = await ChatbotService.setReminder(
              params.date,
              params.message
            );
            break;
          case "USER_PREFERENCES":
            result = await ChatbotService.getUserPreferences();
            break;
          case "SEARCH_INFO":
            result = await ChatbotService.searchInfo(params.query);
            break;
          case "FEEDBACK":
            result = await ChatbotService.saveFeedback(params.message);
            break;
          default:
            result = { success: false, message: "Action non reconnue" };
            break;
        }
      } catch (apiError) {
        // En cas d'erreur (probablement une 404), basculer automatiquement en mode simulation
        console.log(
          `API non disponible pour l'action ${intent}, basculement en mode simulation`,
          apiError
        );

        // Ajouter un message indiquant la simulation
        setMessages((prev) => [
          ...prev,
          {
            text: `‚öôÔ∏è L'API pour cette action n'est pas disponible. Je vous pr√©sente une simulation de ce que vous auriez vu.`,
            isUser: false,
          },
        ]);

        // Utiliser le mock existant pour simuler la r√©ponse
        result = getMockResponse(intent, params);
        result.simulation = true; // Marquer comme simulation
      }

      setActionResult(result);

      // Formater et ajouter le r√©sultat
      setMessages((prev) => [
        ...prev,
        {
          text: formatActionResult(result, intent),
          isUser: false,
        },
      ]);

      // R√©initialiser l'action en cours apr√®s un certain d√©lai
      setTimeout(() => {
        setCurrentAction(null);
        setActionResult(null);
      }, 5000);
    } catch (error) {
      const errorMessage = handleActionError(error, intent);

      setActionResult({
        success: false,
        message:
          error.message ||
          "Une erreur est survenue lors de l'ex√©cution de l'action",
      });

      setMessages((prev) => [...prev, errorMessage]);

      // Si c'est une simulation propos√©e, garder l'action actuelle mais la marquer comme requ√©rant une simulation
      if (errorMessage.requiresSimulation) {
        setCurrentAction({
          intent: "WAITING_FOR_SIMULATION",
          params: {
            originalIntent: intent,
            originalParams: params,
          },
        });
      } else {
        // Sinon, r√©initialiser l'action
        setTimeout(() => {
          setCurrentAction(null);
          setActionResult(null);
        }, 5000);
      }
    } finally {
      setIsActionLoading(false);
    }
  };

  const cancelAction = () => {
    setMessages((prev) => [
      ...prev,
      {
        text: "Action annul√©e. Puis-je vous aider avec autre chose ?",
        isUser: false,
      },
    ]);

    setCurrentAction(null);
    setActionResult(null);
  };

  /**
   * V√©rifie si le message est une simple salutation
   * @param {string} message - Message √† analyser
   * @returns {boolean} - True si c'est une salutation
   */
  const isSimpleGreeting = (message) => {
    const greetings = [
      "bonjour",
      "salut",
      "hello",
      "coucou",
      "bonsoir",
      "hey",
      "bjr",
      "yo",
      "hi",
      "hola",
    ];

    const normalizedMessage = message.toLowerCase().trim();

    // Si le message contient seulement une salutation (avec tol√©rance pour quelques caract√®res en plus)
    return greetings.some(
      (greeting) =>
        normalizedMessage === greeting ||
        normalizedMessage === `${greeting} !` ||
        normalizedMessage === `${greeting}.` ||
        normalizedMessage === `${greeting}!` ||
        normalizedMessage === `${greeting}.`
    );
  };

  /**
   * V√©rifie si le message est une simple expression de gratitude
   * @param {string} message - Message √† analyser
   * @returns {boolean} - True si c'est une expression de gratitude
   */
  const isSimpleGratitude = (message) => {
    const gratitudeExpressions = [
      "merci",
      "thanks",
      "thank you",
      "thx",
      "ty",
      "merci beaucoup",
      "grand merci",
      "je te remercie",
      "je vous remercie",
    ];

    const normalizedMessage = message.toLowerCase().trim();

    // Si le message contient seulement une expression de gratitude (avec tol√©rance)
    return gratitudeExpressions.some(
      (expr) =>
        normalizedMessage === expr ||
        normalizedMessage === `${expr} !` ||
        normalizedMessage === `${expr}.` ||
        normalizedMessage === `${expr}!` ||
        normalizedMessage === `${expr}.`
    );
  };

  /**
   * G√®re les messages de salutation
   * @param {string} message - Message de salutation
   */
  const handleGreeting = (message) => {
    const timeOfDay = new Date().getHours();
    let greeting = "";

    if (timeOfDay >= 5 && timeOfDay < 12) {
      greeting = "Bonjour";
    } else if (timeOfDay >= 12 && timeOfDay < 18) {
      greeting = "Bon apr√®s-midi";
    } else {
      greeting = "Bonsoir";
    }

    const userName = getUserFirstName();
    const greetingWithName = userName ? `${greeting} ${userName}` : greeting;

    const responses = [
      `${greetingWithName} ! Comment puis-je vous aider aujourd'hui ?`,
      `${greetingWithName} ! Que puis-je faire pour vous ?`,
      `${greetingWithName} ! Je suis √† votre service.`,
      `${greetingWithName} ! Besoin d'aide pour la gestion de plannings ou de cong√©s ?`,
    ];

    const response = responses[Math.floor(Math.random() * responses.length)];

    setMessages((prev) => [
      ...prev,
      {
        text: response,
        isUser: false,
      },
    ]);
  };

  /**
   * G√®re les messages de gratitude
   */
  const handleGratitude = () => {
    const responses = [
      "De rien ! Je suis l√† pour vous aider.",
      "Avec plaisir ! Autre chose que je puisse faire pour vous ?",
      "Je vous en prie ! N'h√©sitez pas si vous avez d'autres questions.",
      "C'est mon travail ! Besoin d'autre chose ?",
    ];

    const response = responses[Math.floor(Math.random() * responses.length)];

    setMessages((prev) => [
      ...prev,
      {
        text: response,
        isUser: false,
      },
    ]);
  };

  // Fonction pour basculer le mode personnalis√©
  const togglePersonalizedMode = () => {
    // Si on active le mode personnalis√© et qu'on n'a pas encore le consentement
    if (!isPersonalizedMode && !hasUserConsent) {
      setShowConsentModal(true);
      return;
    }

    setIsPersonalizedMode((prev) => !prev);
    // D√©sactiver le mode agent si on active le mode personnalis√©
    if (!isPersonalizedMode && isAgentMode) {
      setIsAgentMode(false);
    }

    const message = !isPersonalizedMode
      ? "Mode personnalis√© activ√©. J'utiliserai vos informations pour personnaliser mes r√©ponses et mieux vous aider."
      : "Mode personnalis√© d√©sactiv√©. Je n'utiliserai plus vos informations personnelles.";

    setMessages((prev) => [
      ...prev,
      {
        text: message,
        isUser: false,
      },
    ]);
  };

  // Fonction pour basculer le mode agent
  const toggleAgentMode = () => {
    // Si on active le mode agent et qu'on n'a pas encore le consentement
    if (!isAgentMode && !hasUserConsent) {
      setShowConsentModal(true);
      return;
    }

    setIsAgentMode((prev) => !prev);
    // D√©sactiver le mode personnalis√© si on active le mode agent
    if (!isAgentMode && isPersonalizedMode) {
      setIsPersonalizedMode(false);
    }

    const message = !isAgentMode
      ? "Mode agent activ√©. Je peux maintenant vous aider √† cr√©er des plannings en prenant en compte vos contraintes et pr√©f√©rences."
      : "Mode agent d√©sactiv√©. Je reste √† votre disposition pour toute autre question.";

    setMessages((prev) => [
      ...prev,
      {
        text: message,
        isUser: false,
      },
    ]);

    // Si on active le mode agent, proposer de cr√©er un planning
    if (!isAgentMode) {
      setMessages((prev) => [
        ...prev,
        {
          text: "Souhaitez-vous cr√©er un planning ? Je peux vous guider dans le processus en vous posant des questions sur vos contraintes, les horaires d'ouverture, et les pr√©f√©rences de vos employ√©s.",
          isUser: false,
        },
      ]);
    }
  };

  // Fonction pour d√©marrer la cr√©ation d'un planning
  const startScheduleCreation = () => {
    setSchedulingInProgress(true);
    setSchedulingData({
      weekStart: null,
      constraints: [],
      employees: [],
      businessHours: null,
      breakTimes: null,
    });

    setMessages((prev) => [
      ...prev,
      {
        text: "Commen√ßons la cr√©ation d'un planning. Pour quelle semaine souhaitez-vous cr√©er ce planning ? (format JJ/MM/AAAA pour le premier jour de la semaine)",
        isUser: false,
      },
    ]);
  };

  // Fonction pour traiter les r√©ponses de cr√©ation de planning
  const processSchedulingResponse = (userInput) => {
    if (!schedulingData.weekStart) {
      // Traitement de la date de d√©but de semaine
      try {
        const dateParts = userInput.split("/");
        if (dateParts.length === 3) {
          const day = parseInt(dateParts[0], 10);
          const month = parseInt(dateParts[1], 10) - 1;
          const year = parseInt(dateParts[2], 10);
          const date = new Date(year, month, day);

          // V√©rifier si c'est un lundi
          const isMonday = date.getDay() === 1;

          if (isMonday) {
            setSchedulingData((prev) => ({
              ...prev,
              weekStart: date.toISOString().split("T")[0],
            }));

            setMessages((prev) => [
              ...prev,
              {
                text: `Parfait, nous allons cr√©er un planning pour la semaine du ${userInput}. Maintenant, quels sont vos horaires d'ouverture ? (ex: 9h-18h du lundi au vendredi, 10h-17h le samedi)`,
                isUser: false,
              },
            ]);
          } else {
            setMessages((prev) => [
              ...prev,
              {
                text: "La date que vous avez fournie n'est pas un lundi. Pour simplifier, veuillez indiquer un lundi comme premier jour de la semaine.",
                isUser: false,
              },
            ]);
          }
        } else {
          setMessages((prev) => [
            ...prev,
            {
              text: "Format de date incorrect. Veuillez utiliser le format JJ/MM/AAAA (ex: 01/07/2023).",
              isUser: false,
            },
          ]);
        }
      } catch (error) {
        setMessages((prev) => [
          ...prev,
          {
            text: "Je n'ai pas pu interpr√©ter cette date. Veuillez utiliser le format JJ/MM/AAAA (ex: 01/07/2023).",
            isUser: false,
          },
        ]);
      }
      return;
    }

    if (!schedulingData.businessHours) {
      // Traitement des horaires d'ouverture
      setSchedulingData((prev) => ({
        ...prev,
        businessHours: userInput,
      }));

      setMessages((prev) => [
        ...prev,
        {
          text: `J'ai enregistr√© vos horaires d'ouverture: ${userInput}. Y a-t-il des employ√©s en cong√©s cette semaine-l√† ? Si oui, pourriez-vous me donner leurs noms ?`,
          isUser: false,
        },
      ]);
      return;
    }

    if (!schedulingData.constraints.includes("vacations")) {
      // Traitement des cong√©s
      const updatedConstraints = [...schedulingData.constraints, "vacations"];
      setSchedulingData((prev) => ({
        ...prev,
        constraints: updatedConstraints,
      }));

      setMessages((prev) => [
        ...prev,
        {
          text: `Merci pour cette information sur les cong√©s. Y a-t-il des employ√©s qui ont des pr√©f√©rences sp√©cifiques pour leurs jours de repos ?`,
          isUser: false,
        },
      ]);
      return;
    }

    if (!schedulingData.constraints.includes("rest_preferences")) {
      // Traitement des pr√©f√©rences de repos
      const updatedConstraints = [
        ...schedulingData.constraints,
        "rest_preferences",
      ];
      setSchedulingData((prev) => ({
        ...prev,
        constraints: updatedConstraints,
      }));

      setMessages((prev) => [
        ...prev,
        {
          text: `Parfait, j'ai not√© ces pr√©f√©rences. Quel temps de pause minimum souhaitez-vous accorder √† vos employ√©s entre deux journ√©es de travail ?`,
          isUser: false,
        },
      ]);
      return;
    }

    if (!schedulingData.breakTimes) {
      // Traitement des temps de pause
      setSchedulingData((prev) => ({
        ...prev,
        breakTimes: userInput,
      }));

      // Finalisation de la cr√©ation du planning
      setMessages((prev) => [
        ...prev,
        {
          text: `J'ai toutes les informations n√©cessaires pour g√©n√©rer un planning optimal. Je vais maintenant cr√©er ce planning pour la semaine du ${new Date(
            schedulingData.weekStart
          ).toLocaleDateString()}.`,
          isUser: false,
        },
      ]);

      // Appel au service de g√©n√©ration de planning
      generateScheduleWithData();
      return;
    }
  };

  // Fonction pour g√©n√©rer le planning avec les donn√©es collect√©es
  const generateScheduleWithData = async () => {
    try {
      // Code √† supprimer car redondant avec la nouvelle impl√©mentation
      setGenerationStatus("loading");

      // Attendre un d√©lai simul√© pour la g√©n√©ration
      await new Promise((resolve) => setTimeout(resolve, 2000));

      setGenerationStatus("success");
      setSchedulingStep("review");
      addMessage(
        "Planning g√©n√©r√© avec succ√®s ! Veuillez v√©rifier et confirmer.",
        "assistant"
      );

      // Retourner une valeur factice pour l'instant
      return { success: true };
    } catch (error) {
      console.error("Erreur lors de la g√©n√©ration du planning:", error);
      setGenerationStatus("error");
      addMessage(
        "D√©sol√©, une erreur est survenue lors de la g√©n√©ration du planning. Veuillez r√©essayer.",
        "assistant"
      );
      return { success: false, error: error.message };
    }
  };

  /**
   * Traite les requ√™tes sp√©cifiques au mode personnalis√© concernant les informations des employ√©s
   * @param {string} query - La requ√™te de l'utilisateur
   * @returns {Promise<string|null>} - R√©ponse personnalis√©e ou null si pas de correspondance
   */
  const handlePersonalizedEmployeeQuery = async (query) => {
    // Si le mode personnalis√© n'est pas activ√© ou si l'utilisateur n'a pas donn√© son consentement
    if (!isPersonalizedMode || !hasUserConsent) {
      return null;
    }

    // R√©cup√©rer les informations personnalis√©es (maintenant asynchrone)
    const userInfo = await getUserPersonalizedInfo();
    if (!userInfo || !userInfo.equipe) {
      return null;
    }

    // Normaliser la requ√™te
    const normalizedQuery = query.toLowerCase();

    // Traiter les questions sur la date d'embauche d'un employ√© sp√©cifique
    if (
      normalizedQuery.includes("quand") ||
      normalizedQuery.includes("depuis") ||
      normalizedQuery.includes("date d'embauche")
    ) {
      // Rechercher les r√©f√©rences √† un employ√© sp√©cifique
      for (const employee of userInfo.equipe) {
        const firstName = employee.firstName.toLowerCase();
        const lastName = employee.lastName.toLowerCase();
        const fullName = `${firstName} ${lastName}`.toLowerCase();

        if (
          normalizedQuery.includes(firstName) ||
          normalizedQuery.includes(lastName) ||
          normalizedQuery.includes(fullName)
        ) {
          // Formater la date d'embauche
          const hireDate = new Date(employee.hireDate);
          const formattedDate = hireDate.toLocaleDateString("fr-FR", {
            day: "numeric",
            month: "long",
            year: "numeric",
          });

          const hireDateYear = hireDate.getFullYear();
          const currentYear = new Date().getFullYear();
          const yearsOfService = currentYear - hireDateYear;

          return `${employee.firstName} ${
            employee.lastName
          } travaille dans l'entreprise depuis le ${formattedDate}, soit environ ${yearsOfService} an${
            yearsOfService > 1 ? "s" : ""
          } d'anciennet√©. ${employee.firstName} occupe le poste de ${
            employee.role
          } dans le d√©partement ${employee.department}.`;
        }
      }
    }

    // Traiter les questions sur les horaires pr√©f√©r√©s d'un employ√©
    if (
      normalizedQuery.includes("horaire") ||
      normalizedQuery.includes("jour") ||
      normalizedQuery.includes("pr√©f√©r")
    ) {
      // Rechercher les r√©f√©rences √† un employ√© sp√©cifique
      for (const employee of userInfo.equipe) {
        const firstName = employee.firstName.toLowerCase();
        const lastName = employee.lastName.toLowerCase();
        const fullName = `${firstName} ${lastName}`.toLowerCase();

        if (
          normalizedQuery.includes(firstName) ||
          normalizedQuery.includes(lastName) ||
          normalizedQuery.includes(fullName)
        ) {
          const preferredDays = employee.preferredDays.join(", ");
          return `${employee.firstName} ${employee.lastName} pr√©f√®re travailler les jours suivants : ${preferredDays}. ${employee.firstName} est employ√©(e) √† ${employee.hours}h par semaine.`;
        }
      }
    }

    // Traiter les questions sur le d√©partement ou r√¥le d'un employ√©
    if (
      normalizedQuery.includes("d√©partement") ||
      normalizedQuery.includes("√©quipe") ||
      normalizedQuery.includes("r√¥le") ||
      normalizedQuery.includes("poste")
    ) {
      // Rechercher les r√©f√©rences √† un employ√© sp√©cifique
      for (const employee of userInfo.equipe) {
        const firstName = employee.firstName.toLowerCase();
        const lastName = employee.lastName.toLowerCase();
        const fullName = `${firstName} ${lastName}`.toLowerCase();

        if (
          normalizedQuery.includes(firstName) ||
          normalizedQuery.includes(lastName) ||
          normalizedQuery.includes(fullName)
        ) {
          return `${employee.firstName} ${employee.lastName} travaille dans le d√©partement ${employee.department} en tant que ${employee.role}.`;
        }
      }
    }

    // Si aucune correspondance sp√©cifique n'est trouv√©e
    return null;
  };

  // Modifions la fonction handleSubmit pour int√©grer le mode de cr√©ation de planning
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!inputValue.trim()) return;

    // Ajouter le message de l'utilisateur √† la liste des messages
    setMessages((prev) => [...prev, { text: inputValue, isUser: true }]);
    const userMessage = inputValue;
    setInputValue("");

    // Si nous sommes au milieu d'un arbre de dialogue, traiter selon l'arbre
    if (dialogTree && dialogStep) {
      const handled = await handleDialogStep(userMessage);
      if (handled) return;
    }

    // V√©rifier s'il s'agit d'une simple salutation ou remerciement
    if (isSimpleGreeting(userMessage)) {
      handleGreeting(userMessage);
      return;
    }

    if (isSimpleGratitude(userMessage)) {
      handleGratitude();
      return;
    }

    setIsTyping(true);

    try {
      // Utiliser l'int√©gration NLP pour analyser le message
      if (nlpIntegration.current) {
        const result = await nlpIntegration.current.processMessage(userMessage);

        if (result.processed) {
          // Le message a √©t√© trait√© par l'int√©gration NLP
          return;
        }
      }

      // Fallback √† la m√©thode existante
      const { intent, params } = detectIntent(userMessage);

      console.log("Intention d√©tect√©e (c√¥t√© client):", intent, params);

      // Si l'intention est li√©e √† la g√©n√©ration de plannings et que l'Agent IA est activ√©
      if (intent === "GENERATE_SCHEDULE" && isAgentMode) {
        // D√©marrer un arbre de dialogue pour collecter les informations n√©cessaires
        startScheduleGenerationDialog();
        return;
      }

      // Sinon, traiter normalement l'intention
      processIntent(intent, params);
    } catch (error) {
      console.error("Erreur lors du traitement du message:", error);
      setMessages((prev) => [
        ...prev,
        {
          text: "D√©sol√©, j'ai rencontr√© un probl√®me lors du traitement de votre demande. Pourriez-vous reformuler ou essayer une autre question ?",
          isUser: false,
        },
      ]);
    } finally {
      setIsTyping(false);
    }
  };

  const getUserFirstName = () => {
    console.log("User data:", user);

    if (user && user.firstName) {
      return user.firstName;
    } else if (user && user.first_name) {
      return user.first_name;
    } else if (user && user.name) {
      return user.name.split(" ")[0];
    }
    return "utilisateur";
  };

  // Afficher les d√©tails de l'action en cours
  const renderActionDetails = () => {
    if (!currentAction) return null;

    const { intent, params } = currentAction;

    return (
      <ActionCard>
        <ActionTitle>{getActionTitle(intent)}</ActionTitle>

        {intent.includes("SCHEDULE") && params.weekStart && (
          <ActionDetail>
            <span>Semaine du :</span>
            <span>{params.weekStart}</span>
          </ActionDetail>
        )}

        {intent.includes("VACATION") && params.startDate && params.endDate && (
          <>
            <ActionDetail>
              <span>Date de d√©but :</span>
              <span>{params.startDate}</span>
            </ActionDetail>
            <ActionDetail>
              <span>Date de fin :</span>
              <span>{params.endDate}</span>
            </ActionDetail>
          </>
        )}

        {intent === "CREATE_VACATION_REQUEST" && params.type && (
          <ActionDetail>
            <span>Type de cong√© :</span>
            <span>
              {params.type === "vacation" && "Cong√©s pay√©s"}
              {params.type === "sick_leave" && "Arr√™t maladie"}
              {params.type === "training" && "Formation"}
              {params.type === "family" && "Cong√© familial"}
              {params.type === "unpaid" && "Cong√© sans solde"}
            </span>
          </ActionDetail>
        )}

        {intent === "GET_STATS" && params.period && (
          <ActionDetail>
            <span>P√©riode :</span>
            <span>
              {params.period === "week" && "Semaine"}
              {params.period === "month" && "Mois"}
              {params.period === "year" && "Ann√©e"}
            </span>
          </ActionDetail>
        )}

        {!actionResult && !isActionLoading && (
          <ActionsContainer>
            <ActionButton onClick={executeAction}>Confirmer</ActionButton>
            <ActionButton
              onClick={cancelAction}
              style={{
                backgroundColor: "transparent",
                color: "inherit",
                border: "1px solid #ddd",
              }}
            >
              Annuler
            </ActionButton>
          </ActionsContainer>
        )}

        {isActionLoading && (
          <div style={{ textAlign: "center", padding: "8px" }}>
            Traitement en cours...
          </div>
        )}

        {actionResult && (
          <ActionResult $success={actionResult.success}>
            {actionResult.message}
          </ActionResult>
        )}
      </ActionCard>
    );
  };

  /**
   * G√®re l'acceptation du consentement RGPD
   */
  const handleConsentAccept = () => {
    setHasUserConsent(true);
    localStorage.setItem("chatbot_data_consent", "true");
    setShowConsentModal(false);

    // Activer automatiquement le mode personnalis√© ou agent selon la demande
    if (!isPersonalizedMode && !isAgentMode) {
      setIsPersonalizedMode(true);

      setMessages((prev) => [
        ...prev,
        {
          text: "Merci d'avoir accept√© le traitement de vos donn√©es. J'ai activ√© le mode personnalis√© pour vous offrir une exp√©rience sur mesure. Vous pouvez le d√©sactiver √† tout moment.",
          isUser: false,
        },
      ]);
    }
  };

  /**
   * G√®re le refus du consentement RGPD
   */
  const handleConsentDecline = () => {
    setHasUserConsent(false);
    localStorage.setItem("chatbot_data_consent", "false");
    setShowConsentModal(false);

    // D√©sactiver le mode personnalis√© ou agent si actif
    if (isPersonalizedMode || isAgentMode) {
      setIsPersonalizedMode(false);
      setIsAgentMode(false);

      setMessages((prev) => [
        ...prev,
        {
          text: "J'ai bien pris en compte votre refus. Je n'utiliserai pas vos donn√©es personnelles. Je reste disponible pour r√©pondre √† vos questions g√©n√©rales.",
          isUser: false,
        },
      ]);
    } else {
      setMessages((prev) => [
        ...prev,
        {
          text: "J'ai bien pris en compte votre refus. Je reste disponible pour r√©pondre √† vos questions g√©n√©rales sans utiliser vos donn√©es personnelles.",
          isUser: false,
        },
      ]);
    }
  };

  // Si l'utilisateur n'est pas connect√© ou si on est sur une page restreinte, ne pas afficher le chatbot
  if (!shouldShowChatbot()) {
    return null;
  }

  // Fonction pour afficher la progression de la cr√©ation de planning
  const renderSchedulingProgress = () => {
    if (!schedulingInProgress) return null;

    const steps = [
      {
        key: "weekStart",
        label: "Date de d√©but de semaine",
        completed: !!schedulingData.weekStart,
      },
      {
        key: "businessHours",
        label: "Horaires d'ouverture",
        completed: !!schedulingData.businessHours,
      },
      {
        key: "vacations",
        label: "Cong√©s des employ√©s",
        completed: schedulingData.constraints.includes("vacations"),
      },
      {
        key: "restPreferences",
        label: "Pr√©f√©rences de repos",
        completed: schedulingData.constraints.includes("rest_preferences"),
      },
      {
        key: "breakTimes",
        label: "Temps de pause",
        completed: !!schedulingData.breakTimes,
      },
    ];

    // Trouver l'√©tape active (la premi√®re qui n'est pas compl√©t√©e)
    const activeStepIndex = steps.findIndex((step) => !step.completed);

    return (
      <SchedulingProgressContainer>
        <ProgressTitle>
          <span role="img" aria-label="Calendrier">
            üìÖ
          </span>
          Cr√©ation de planning en cours
        </ProgressTitle>
        <ProgressSteps>
          {steps.map((step, index) => (
            <ProgressStep
              key={step.key}
              completed={step.completed}
              active={index === activeStepIndex}
            >
              <StepIndicator
                completed={step.completed}
                active={index === activeStepIndex}
              >
                {step.completed ? "‚úì" : index + 1}
              </StepIndicator>
              {step.label}
            </ProgressStep>
          ))}
        </ProgressSteps>
      </SchedulingProgressContainer>
    );
  };

  /**
   * Traiter un message de l'utilisateur
   * @param {string} message - Message de l'utilisateur
   */
  const processMessage = async (message) => {
    try {
      setIsTyping(true);

      // V√©rifier s'il s'agit d'une simple salutation ou remerciement
      if (isSimpleGreeting(message)) {
        handleGreeting(message);
        setIsTyping(false);
        return;
      }

      if (isSimpleGratitude(message)) {
        handleGratitude();
        setIsTyping(false);
        return;
      }

      // V√©rifier si on est en dialogue structur√© (arbre de dialogue)
      if (dialogTree && dialogStep) {
        // Traiter la r√©ponse dans l'arbre de dialogue
        const currentStep = dialogTree[dialogStep];
        if (currentStep && currentStep.handler) {
          await currentStep.handler(message);
          setIsTyping(false);
          return;
        }
      }

      // D√©tecter l'intention via le service NLP
      try {
        const result = await ChatbotService.processMessage(message);

        console.log("R√©sultat NLP:", result);

        if (result.intent === "GENERATE_SCHEDULE" && !result.fromFallback) {
          // Si l'intention est de g√©n√©rer un planning et d√©tect√© par l'API (pas un fallback)
          startScheduleGenerationDialog();
        } else if (result.intent !== "UNKNOWN") {
          // Traiter l'intention d√©tect√©e
          await processIntent(result.intent, result.entities);
        } else {
          // Intention inconnue, essayer de la comprendre avec GPT
          const responseFromGPT = await getLocalResponse(message);
          addMessage(responseFromGPT, "assistant");
        }
      } catch (error) {
        console.error("Erreur lors de la d√©tection d'intention:", error);

        // Mode d√©grad√©: d√©tecter l'intention localement
        const intent = ChatbotService.detectBasicIntent(message);

        if (intent === "GENERATE_SCHEDULE") {
          startScheduleGenerationDialog();
        } else if (intent !== "UNKNOWN") {
          await processIntent(intent, {});
        } else {
          const responseFromGPT = await getLocalResponse(message);
          addMessage(responseFromGPT, "assistant");
        }
      }
    } catch (error) {
      console.error("Erreur dans le traitement du message:", error);
      addMessage(
        "D√©sol√©, j'ai rencontr√© une erreur lors du traitement de votre message.",
        "assistant"
      );
    } finally {
      setIsTyping(false);
    }
  };

  // Fonction pour d√©marrer l'arbre de dialogue pour la g√©n√©ration de planning
  const startScheduleGenerationDialog = useCallback(() => {
    const tree = createScheduleGenerationTree();
    setDialogTree(tree);
    setDialogStep("start");
    setCollectedData({});

    // Afficher le message initial
    setMessages((prev) => [
      ...prev,
      {
        text: tree.start.message,
        isUser: false,
      },
    ]);
  }, []);

  // Fonction pour g√©rer les √©tapes du dialogue pour la g√©n√©ration de planning
  const handleDialogStep = useCallback(
    async (userInput) => {
      if (!dialogTree || !dialogStep) return false;

      // Valider l'entr√©e pour l'√©tape actuelle
      const validationResult = validateStepInput(
        dialogStep,
        userInput,
        collectedData
      );

      if (!validationResult.isValid) {
        // Si l'entr√©e n'est pas valide, afficher l'erreur
        setMessages((prev) => [
          ...prev,
          {
            text: validationResult.error,
            isUser: false,
          },
        ]);
        return true;
      }

      // Mettre √† jour les donn√©es collect√©es
      const newData = { ...collectedData };

      switch (dialogStep) {
        case "start":
          newData.weekStart = validationResult.processedValue;
          break;
        case "department":
          newData.department = validationResult.processedValue;
          break;
        case "employee_selection":
          newData.employeeSelection = validationResult.processedValue;
          break;
        case "select_employees":
          newData.selectedEmployees = validationResult.processedValue;
          break;
        case "min_hours":
          newData.minHours = validationResult.processedValue;
          break;
        case "max_hours":
          newData.maxHours = validationResult.processedValue;
          break;
        case "opening_hours":
          newData.openingHours = validationResult.processedValue;
          break;
        case "special_requests":
          newData.specialRequests = validationResult.processedValue;
          // G√©n√©rer un r√©sum√© pour confirmation
          setMessages((prev) => [
            ...prev,
            {
              text: generateScheduleSummary(newData),
              isUser: false,
            },
          ]);
          break;
        case "confirmation":
          if (validationResult.processedValue) {
            // G√©n√©rer le planning
            await handleGenerateSchedule(newData);
          } else {
            // Annuler la g√©n√©ration
            setMessages((prev) => [
              ...prev,
              {
                text: "G√©n√©ration annul√©e. Vous pouvez recommencer ou me demander autre chose.",
                isUser: false,
              },
            ]);
            // R√©initialiser l'arbre de dialogue
            setDialogTree(null);
            setDialogStep(null);
            setCollectedData({});
          }
          return true;
        default:
          break;
      }

      setCollectedData(newData);

      // Passer √† l'√©tape suivante si d√©finie
      if (validationResult.nextStep) {
        const nextStep = validationResult.nextStep;
        setDialogStep(nextStep);

        // Afficher le message pour la prochaine √©tape s'il existe
        if (dialogTree[nextStep] && dialogTree[nextStep].message) {
          setMessages((prev) => [
            ...prev,
            {
              text: dialogTree[nextStep].message,
              isUser: false,
            },
          ]);
        }
      }

      return true;
    },
    [dialogTree, dialogStep, collectedData]
  );

  // Fonction pour g√©n√©rer un planning avec les donn√©es collect√©es
  const handleGenerateSchedule = useCallback(async (data) => {
    try {
      setIsTyping(true);
      setMessages((prev) => [
        ...prev,
        {
          text: "G√©n√©ration du planning en cours...",
          isUser: false,
        },
      ]);

      // Appeler l'API pour g√©n√©rer le planning
      if (nlpIntegration.current) {
        const result = await nlpIntegration.current.generateSchedule(data);

        if (result.success) {
          setMessages((prev) => [
            ...prev,
            {
              text: "‚úÖ Planning g√©n√©r√© avec succ√®s! Vous pouvez maintenant le consulter et l'ajuster.",
              isUser: false,
            },
          ]);

          // Afficher les statistiques
          if (result.stats) {
            setMessages((prev) => [
              ...prev,
              {
                text: formatScheduleStats(result.stats),
                isUser: false,
              },
            ]);
          }

          // Ouvrir la modal de validation
          setGeneratedSchedule(result);
          setScheduleValidationOpen(true);
        } else {
          setMessages((prev) => [
            ...prev,
            {
              text: `‚ùå Erreur lors de la g√©n√©ration du planning: ${
                result.message || "Une erreur est survenue"
              }`,
              isUser: false,
            },
          ]);
        }
      }
    } catch (error) {
      console.error("Erreur lors de la g√©n√©ration du planning:", error);
      setMessages((prev) => [
        ...prev,
        {
          text: "‚ùå Une erreur est survenue lors de la g√©n√©ration du planning. Veuillez r√©essayer ult√©rieurement.",
          isUser: false,
        },
      ]);
    } finally {
      setIsTyping(false);
      // R√©initialiser l'arbre de dialogue
      setDialogTree(null);
      setDialogStep(null);
    }
  }, []);

  // Fonction pour appliquer le planning valid√©
  const handleApplySchedule = useCallback((schedule) => {
    setScheduleValidationOpen(false);
    setMessages((prev) => [
      ...prev,
      {
        text: "Planning appliqu√© avec succ√®s! Il est maintenant disponible dans la section Planning.",
        isUser: false,
      },
    ]);

    // Ici, ajoutez la logique pour enregistrer d√©finitivement le planning
    // Par exemple, appeler une API pour enregistrer dans la base de donn√©es
  }, []);

  // Fonction pour r√©g√©n√©rer le planning
  const handleRegenerateSchedule = useCallback(() => {
    setScheduleValidationOpen(false);
    handleGenerateSchedule(collectedData);
  }, [collectedData, handleGenerateSchedule]);

  // Initialiser l'int√©gration NLP
  useEffect(() => {
    if (!nlpIntegration.current) {
      nlpIntegration.current = ChatbotNlpIntegration({
        onProcessMessage: processIntent,
        onStartScheduleGeneration: startScheduleGenerationDialog,
        onAddMessage: (text, role) =>
          setMessages((prev) => [...prev, { text, isUser: role === "user" }]),
        onSetIsTyping: setIsTyping,
      });
    }
  }, []);

  return (
    <>
      {shouldShowChatbot() && (
        <ChatbotContainer>
          {showWelcome && !isOpen && (
            <WelcomeMessage>
              Bonjour {getUserFirstName()}, besoin d'aide ?
            </WelcomeMessage>
          )}

          {showHelpBubble && !isOpen && (
            <HelpBubble $show={showHelpBubble}>
              Bonjour {getUserFirstName()} !
            </HelpBubble>
          )}

          {isOpen && (
            <ChatWindow>
              <ChatHeader>
                <ChatTitle>
                  <Lottie
                    animationData={robotAnimation}
                    style={{ width: 30, height: 30 }}
                  />
                  Assistant IA
                </ChatTitle>

                <ModeToggleContainer>
                  <ModeButton
                    active={isPersonalizedMode}
                    mode="personalized"
                    onClick={togglePersonalizedMode}
                  >
                    <span role="img" aria-label="Personnalis√©">
                      üë§
                    </span>{" "}
                    Personnalis√©
                  </ModeButton>

                  <ModeButton
                    active={isAgentMode}
                    mode="agent"
                    onClick={toggleAgentMode}
                  >
                    <span role="img" aria-label="Agent">
                      ü§ñ
                    </span>{" "}
                    Agent
                  </ModeButton>
                </ModeToggleContainer>

                <CloseButton onClick={toggleChat}>
                  <FaTimes />
                </CloseButton>
              </ChatHeader>

              <ChatMessages>
                {messages.map((msg, index) => (
                  <Message
                    key={index}
                    isUser={msg.isUser}
                    personalized={!msg.isUser && isPersonalizedMode}
                    agent={!msg.isUser && isAgentMode}
                  >
                    {!msg.isUser &&
                      index > 0 &&
                      (isPersonalizedMode || isAgentMode) && (
                        <ModeBadge
                          mode={isPersonalizedMode ? "personalized" : "agent"}
                        >
                          {isPersonalizedMode ? (
                            <>
                              <span role="img" aria-label="Personnalis√©">
                                üë§
                              </span>{" "}
                              Mode Personnalis√©
                            </>
                          ) : (
                            <>
                              <span role="img" aria-label="Agent">
                                ü§ñ
                              </span>{" "}
                              Mode Agent
                            </>
                          )}
                        </ModeBadge>
                      )}
                    {msg.text}
                  </Message>
                ))}

                {/* Afficher la progression de cr√©ation de planning si en mode agent */}
                {isAgentMode &&
                  schedulingInProgress &&
                  renderSchedulingProgress()}

                {isLoading && (
                  <Message
                    isUser={false}
                    personalized={isPersonalizedMode}
                    agent={isAgentMode}
                  >
                    <LoadingIndicator>
                      <Dot />
                      <Dot />
                      <Dot />
                    </LoadingIndicator>
                  </Message>
                )}
                <div ref={messagesEndRef} />
              </ChatMessages>

              {currentAction && actionResult && renderActionDetails()}

              <ChatInputContainer onSubmit={handleSubmit}>
                <ChatInput
                  type="text"
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  placeholder={
                    schedulingInProgress
                      ? "R√©pondez √† la question pour cr√©er le planning..."
                      : currentAction
                      ? currentAction.intent === "WAITING_FOR_SIMULATION"
                        ? "Voulez-vous une simulation ? (oui/non)"
                        : "Confirmez-vous cette action ? (oui/non)"
                      : isAgentMode
                      ? "Demandez 'Cr√©er un planning', 'V√©rifier les cong√©s'..."
                      : isPersonalizedMode
                      ? "Ex: 'Mes prochains cong√©s', 'Mon planning de la semaine'..."
                      : "Comment puis-je vous aider aujourd'hui ?"
                  }
                  ref={inputRef}
                  disabled={isActionLoading}
                />
                <SendButton type="submit" disabled={isActionLoading}>
                  {isActionLoading ? <Spinner /> : <FaPaperPlane />}
                </SendButton>
              </ChatInputContainer>
            </ChatWindow>
          )}

          <RobotButton
            onClick={toggleChat}
            title="Assistant IA"
            onMouseEnter={() => !isOpen && setShowWelcome(true)}
            onMouseLeave={() => setShowWelcome(false)}
          >
            <div style={{ width: 40, height: 40 }}>
              <Lottie animationData={robotAnimation} loop={true} />
            </div>
          </RobotButton>

          {/* Modals et bulles d'aide */}
          {showConsentModal && (
            <ConsentModal
              onAccept={handleConsentAccept}
              onDecline={handleConsentDecline}
            />
          )}

          {/* Modal de validation de planning */}
          <ScheduleValidationModalWrapper
            open={scheduleValidationOpen}
            onClose={() => setScheduleValidationOpen(false)}
            generatedSchedule={generatedSchedule}
            onApplySchedule={handleApplySchedule}
            onRegenerateSchedule={handleRegenerateSchedule}
            loading={isTyping}
            error={null}
          />
        </ChatbotContainer>
      )}
    </>
  );
};

export default Chatbot;
