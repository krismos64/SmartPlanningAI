import { API_ENDPOINTS, API_URL, apiRequest } from "../config/api";
import { formatDateForAPI } from "../utils/dateUtils";
import { formatError } from "../utils/errorHandling";

/**
 * Fonction utilitaire pour normaliser les r√©ponses API
 * Assure que les r√©ponses ont toujours la structure { success, message, data }
 * @param {*} response - La r√©ponse √† normaliser
 * @returns {Object} - R√©ponse normalis√©e
 */
const normalizeResponse = (response) => {
  // Cas d'erreur
  if (!response) {
    return { success: false, message: "Aucune r√©ponse re√ßue", data: null };
  }

  // Si la r√©ponse a d√©j√† la structure attendue
  if (typeof response.success === "boolean") {
    // S'assurer que le message est une cha√Æne
    const message =
      response.message ||
      (response.success ? "Op√©ration r√©ussie" : "Erreur lors de l'op√©ration");

    return {
      success: response.success,
      message: typeof message === "string" ? message : String(message),
      data: response.data || null,
      error: response.error ? formatError(response.error) : null,
    };
  }

  // Si la r√©ponse est un objet direct (ancienne API)
  return {
    success: true,
    message: "Op√©ration r√©ussie",
    data: response,
  };
};

export const AuthService = {
  login: async (email, password) => {
    console.log("üîê Tentative de connexion avec:", { email, password: "***" });
    try {
      const response = await apiRequest(API_ENDPOINTS.LOGIN, "POST", {
        email,
        password,
      });

      if (response.error) {
        console.error("‚ùå Erreur de connexion:", response.error);
        return { success: false, message: response.error };
      }

      if (response.token) {
        console.log("‚úÖ Connexion r√©ussie, token re√ßu");
        localStorage.setItem("token", response.token);
        localStorage.setItem(
          "user",
          JSON.stringify({
            id: response.id,
            email: response.email,
            role: response.role,
            first_name: response.first_name,
            last_name: response.last_name,
          })
        );
        return { success: true, user: response };
      } else {
        console.error("‚ùå Connexion √©chou√©e: pas de token re√ßu");
        return { success: false, message: "Erreur d'authentification" };
      }
    } catch (error) {
      console.error("‚ùå Erreur lors de la connexion:", error);
      return {
        success: false,
        message: error.message || "Erreur de connexion",
      };
    }
  },

  me: async (token) => {
    try {
      console.log("üîç R√©cup√©ration des infos du profil utilisateur");
      const response = await apiRequest("/api/user/profile", "GET");
      if (response.error) {
        return { success: false, message: response.error };
      }
      return { success: true, user: response };
    } catch (error) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration du profil:", error);
      return {
        success: false,
        message: error.message || "Erreur lors de la r√©cup√©ration du profil",
      };
    }
  },

  register: async (userData) => {
    try {
      const response = await apiRequest(API_ENDPOINTS.REGISTER, "POST", {
        ...userData,
        first_name: userData.first_name,
        last_name: userData.last_name,
      });

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, user: response };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Erreur d'inscription",
      };
    }
  },

  logout: () => {
    localStorage.removeItem("token");
    localStorage.removeItem("user");
    return { success: true };
  },

  getCurrentUser: () => {
    const userStr = localStorage.getItem("user");
    if (!userStr) return null;

    try {
      return JSON.parse(userStr);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de l'utilisateur:", error);
      return null;
    }
  },

  requestAccountDeletion: async () => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.AUTH.REQUEST_ACCOUNT_DELETION,
        "POST"
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return {
        success: true,
        message: "Un email de confirmation a √©t√© envoy√© √† votre adresse email.",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.message || "Erreur lors de la demande de suppression de compte",
      };
    }
  },

  confirmAccountDeletion: async (token) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.AUTH.CONFIRM_ACCOUNT_DELETION,
        "POST",
        { token }
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      // D√©connexion apr√®s suppression r√©ussie
      localStorage.removeItem("token");
      localStorage.removeItem("user");

      return {
        success: true,
        message: "Votre compte a √©t√© supprim√© avec succ√®s.",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.message ||
          "Erreur lors de la confirmation de suppression de compte",
      };
    }
  },
};

export const EmployeeService = {
  getAll: async () => {
    try {
      const response = await apiRequest(API_ENDPOINTS.EMPLOYEES.BASE, "GET");
      return normalizeResponse(response);
    } catch (error) {
      console.error("Erreur EmployeeService.getAll:", error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },

  getById: async (id) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.EMPLOYEES.BY_ID(id),
        "GET"
      );
      return normalizeResponse(response);
    } catch (error) {
      console.error(`Erreur EmployeeService.getById(${id}):`, error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },

  create: async (employeeData) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.EMPLOYEES.BASE,
        "POST",
        employeeData
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, employee: response };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Erreur lors de la cr√©ation de l'employ√©",
      };
    }
  },

  update: async (id, employeeData) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.EMPLOYEES.BY_ID(id),
        "PUT",
        employeeData
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, employee: response };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Erreur lors de la mise √† jour de l'employ√©",
      };
    }
  },

  delete: async (id) => {
    try {
      console.log(`Suppression du planning ${id}...`);
      const response = await apiRequest(
        `${API_ENDPOINTS.WEEKLY_SCHEDULES}/${id}`,
        "DELETE"
      );

      console.log(`R√©ponse de la suppression du planning ${id}:`, response);

      // G√©rer les erreurs sp√©cifiques retourn√©es avec un code 4xx/5xx
      if (response && response.success === false) {
        console.error(
          `Erreur de suppression du planning ${id}:`,
          response.message
        );
        return {
          success: false,
          message:
            response.message || "Erreur lors de la suppression du planning",
        };
      }

      return { success: true };
    } catch (error) {
      console.error(
        `Erreur d'API lors de la suppression du planning ${id}:`,
        error
      );
      return {
        success: false,
        message: error.message || "Erreur lors de la suppression du planning",
      };
    }
  },
};

export const VacationService = {
  getAll: async () => {
    try {
      console.log("VacationService.getAll - Appel de l'API");

      // R√©cup√©rer le token et l'utilisateur du localStorage pour le d√©bogage
      const token = localStorage.getItem("token");
      const userString = localStorage.getItem("user");
      let user = null;
      try {
        user = JSON.parse(userString);
        console.log("VacationService.getAll - Utilisateur courant:", user);
      } catch (e) {
        console.error(
          "VacationService.getAll - Erreur parsing utilisateur:",
          e
        );
      }

      console.log(
        "VacationService.getAll - Envoi de la requ√™te avec token:",
        token ? token.substring(0, 15) + "..." : "non d√©fini"
      );

      // Appel direct √† l'API pour acc√©der aux d√©tails complets de la r√©ponse
      const response = await fetch(API_URL + API_ENDPOINTS.VACATIONS.BASE, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });

      console.log("VacationService.getAll - R√©ponse status:", response.status);
      console.log("VacationService.getAll - Headers:", [
        ...response.headers.entries(),
      ]);

      // Obtenir le corps de la r√©ponse
      const responseText = await response.text();
      console.log(
        "VacationService.getAll - Texte brut de la r√©ponse:",
        responseText
      );

      // Tenter de parser la r√©ponse en JSON
      let data;
      try {
        data = responseText ? JSON.parse(responseText) : null;
        console.log("VacationService.getAll - Donn√©es JSON:", data);
      } catch (e) {
        console.error("VacationService.getAll - Erreur parsing JSON:", e);
        return { success: false, message: "Erreur de format dans la r√©ponse" };
      }

      // Normaliser et retourner la r√©ponse
      return normalizeResponse(data);
    } catch (error) {
      console.error("VacationService.getAll - Erreur:", error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },

  getById: async (id) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.VACATIONS.BY_ID(id),
        "GET"
      );
      return normalizeResponse(response);
    } catch (error) {
      console.error(`Erreur VacationService.getById(${id}):`, error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },

  create: async (vacationData) => {
    try {
      console.log("VacationService.create - Donn√©es re√ßues:", vacationData);

      // S'assurer que les champs obligatoires sont pr√©sents
      if (
        !vacationData.employee_id ||
        !vacationData.start_date ||
        !vacationData.end_date ||
        !vacationData.type
      ) {
        console.error(
          "Erreur VacationService.create: Champs obligatoires manquants"
        );
        return {
          success: false,
          error:
            "Les champs employee_id, start_date, end_date et type sont obligatoires",
          message:
            "Les champs employee_id, start_date, end_date et type sont obligatoires",
        };
      }

      // Formater les dates au format ISO (YYYY-MM-DD)
      const formattedData = {
        ...vacationData,
        start_date: formatDateForAPI(vacationData.start_date),
        end_date: formatDateForAPI(vacationData.end_date),
      };

      console.log("VacationService.create - Donn√©es format√©es:", formattedData);

      const response = await apiRequest(
        API_ENDPOINTS.VACATIONS.BASE,
        "POST",
        formattedData
      );
      return normalizeResponse(response);
    } catch (error) {
      console.error("Erreur VacationService.create:", error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },

  update: async (id, vacationData) => {
    try {
      const formattedData = {
        ...vacationData,
        start_date: formatDateForAPI(
          vacationData.startDate || vacationData.start_date
        ),
        end_date: formatDateForAPI(
          vacationData.endDate || vacationData.end_date
        ),
      };

      const response = await apiRequest(
        API_ENDPOINTS.VACATIONS.BY_ID(id),
        "PUT",
        formattedData
      );
      return normalizeResponse(response);
    } catch (error) {
      console.error(`Erreur VacationService.update(${id}):`, error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },

  delete: async (id) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.VACATIONS.BY_ID(id),
        "DELETE"
      );
      return normalizeResponse(response);
    } catch (error) {
      console.error(`Erreur VacationService.delete(${id}):`, error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },

  updateStatus: async (id, status, comment = "") => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.VACATIONS.UPDATE_STATUS(id),
        "PUT",
        { status, comment }
      );
      return normalizeResponse(response);
    } catch (error) {
      console.error(
        `Erreur VacationService.updateStatus(${id}, ${status}):`,
        error
      );
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },
};

export const ActivityService = {
  getAll: async () => {
    try {
      const response = await apiRequest(API_ENDPOINTS.ACTIVITIES.LIST, "GET");

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, activities: response };
    } catch (error) {
      return {
        success: false,
        message:
          error.message || "Erreur lors de la r√©cup√©ration des activit√©s",
      };
    }
  },

  getByUser: async (userId) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.ACTIVITIES.BY_USER(userId),
        "GET"
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, activities: response };
    } catch (error) {
      return {
        success: false,
        message:
          error.message ||
          "Erreur lors de la r√©cup√©ration des activit√©s de l'utilisateur",
      };
    }
  },

  create: async (activityData) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.ACTIVITIES.CREATE,
        "POST",
        activityData
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, activity: response };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Erreur lors de la cr√©ation de l'activit√©",
      };
    }
  },

  update: async (id, activityData) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.ACTIVITIES.UPDATE(id),
        "PUT",
        activityData
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, activity: response };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Erreur lors de la mise √† jour de l'activit√©",
      };
    }
  },

  delete: async (id) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.ACTIVITIES.DELETE(id),
        "DELETE"
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Erreur lors de la suppression de l'activit√©",
      };
    }
  },
};

export const WeeklyScheduleService = {
  getAll: async () => {
    try {
      const response = await apiRequest(API_ENDPOINTS.WEEKLY_SCHEDULES, "GET");

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, schedules: response };
    } catch (error) {
      return {
        success: false,
        message:
          error.message || "Erreur lors de la r√©cup√©ration des plannings",
      };
    }
  },

  getByWeek: async (weekStart) => {
    try {
      if (!weekStart) {
        console.error("Date de d√©but de semaine non sp√©cifi√©e");
        return { success: false, message: "Date de d√©but de semaine requise" };
      }

      // V√©rifier que le token d'authentification est pr√©sent
      const token = localStorage.getItem("token");
      console.error(
        "Token d'authentification:",
        token ? "Pr√©sent" : "Manquant",
        token ? `(${token.substring(0, 10)}...)` : ""
      );

      if (!token) {
        console.error("Token d'authentification manquant");
        return {
          success: false,
          message: "Vous devez √™tre connect√© pour acc√©der √† ces donn√©es",
        };
      }

      console.error(
        "Appel API pour r√©cup√©rer les plannings de la semaine:",
        weekStart
      );

      try {
        const response = await apiRequest(
          `${API_ENDPOINTS.WEEKLY_SCHEDULES}/week/${weekStart}`,
          "GET"
        );

        if (response.error) {
          console.error(
            "Erreur API lors de la r√©cup√©ration des plannings:",
            response.error
          );
          return {
            success: false,
            message: response.error,
            details: response.details || "",
          };
        }

        console.error(
          "R√©ponse API pour les plannings:",
          JSON.stringify(response).substring(0, 200) + "..."
        );

        // Normaliser la structure de la r√©ponse pour garantir un format coh√©rent
        if (
          response &&
          response._originalResponse &&
          response._originalResponse.data
        ) {
          // Cas o√π la r√©ponse contient la structure normalis√©e avec _originalResponse
          return {
            success: true,
            schedules: Array.isArray(response._originalResponse.data)
              ? response._originalResponse.data
              : [],
          };
        } else if (response && response.data && Array.isArray(response.data)) {
          // Cas o√π la r√©ponse contient directement un champ data qui est un tableau
          return { success: true, schedules: response.data };
        } else if (Array.isArray(response)) {
          // Cas o√π la r√©ponse est directement un tableau
          return { success: true, schedules: response };
        } else {
          // Cas par d√©faut - on retourne une structure attendue avec un tableau vide si n√©cessaire
          return {
            success: true,
            schedules: response && Array.isArray(response) ? response : [],
          };
        }
      } catch (apiError) {
        console.error("Exception lors de l'appel API:", apiError);
        return {
          success: false,
          message:
            apiError.message || "Erreur lors de la r√©cup√©ration des plannings",
          details: apiError.details || "",
        };
      }
    } catch (error) {
      console.error("Exception lors de la r√©cup√©ration des plannings:", error);
      return {
        success: false,
        message:
          error.message ||
          "Erreur lors de la r√©cup√©ration des plannings pour cette semaine",
        details: error.details || "",
      };
    }
  },

  getByEmployee: async (employeeId) => {
    try {
      const response = await apiRequest(
        `${API_ENDPOINTS.EMPLOYEES.SCHEDULES(employeeId)}`,
        "GET"
      );

      if (response.error) {
        return { success: false, message: response.error };
      }

      return { success: true, schedules: response };
    } catch (error) {
      return {
        success: false,
        message:
          error.message ||
          "Erreur lors de la r√©cup√©ration des plannings de l'employ√©",
      };
    }
  },

  getByEmployeeAndWeek: async (employeeId, weekStart) => {
    try {
      if (!employeeId) {
        console.error("ID employ√© non sp√©cifi√©");
        return { success: false, message: "ID employ√© requis" };
      }

      if (!weekStart) {
        console.error("Date de d√©but de semaine non sp√©cifi√©e");
        return { success: false, message: "Date de d√©but de semaine requise" };
      }

      // S'assurer que la date est au format YYYY-MM-DD
      let formattedDate = weekStart;
      if (weekStart instanceof Date) {
        formattedDate = formatDateForAPI(weekStart);
      } else if (typeof weekStart === "string" && weekStart.includes("T")) {
        // Si la date contient un T (format ISO), extraire seulement la partie date
        formattedDate = weekStart.split("T")[0];
      }

      console.error(
        "Appel API pour r√©cup√©rer le planning de l'employ√©:",
        employeeId,
        "semaine du:",
        formattedDate
      );

      const response = await apiRequest(
        `${API_ENDPOINTS.WEEKLY_SCHEDULES}/employee/${employeeId}/week/${formattedDate}`,
        "GET"
      );

      if (response.error) {
        console.error(
          "Erreur API lors de la r√©cup√©ration du planning:",
          response.error
        );
        return { success: false, message: response.error };
      }

      return response; // La r√©ponse contient d√©j√† success et schedule
    } catch (error) {
      console.error("Exception lors de la r√©cup√©ration du planning:", error);
      return {
        success: false,
        message: error.message || "Erreur lors de la r√©cup√©ration du planning",
      };
    }
  },

  create: async (scheduleData) => {
    try {
      console.log("Cr√©ation d'un nouveau planning:", scheduleData);

      // Utiliser l'URL compl√®te avec API_URL pour s'assurer que la requ√™te est correctement rout√©e
      const response = await apiRequest(
        API_ENDPOINTS.WEEKLY_SCHEDULES,
        "POST",
        scheduleData
      );

      if (response.error) {
        console.error(
          "Erreur lors de la cr√©ation du planning:",
          response.error
        );
        return { success: false, message: response.error };
      }

      console.log("Planning cr√©√© avec succ√®s:", response);

      // Normaliser la r√©ponse pour s'assurer que tous les champs n√©cessaires sont pr√©sents
      return {
        success: true,
        schedule: response.data || response,
      };
    } catch (error) {
      console.error("Exception lors de la cr√©ation du planning:", error);
      return {
        success: false,
        message: error.message || "Erreur lors de la cr√©ation du planning",
      };
    }
  },

  update: async (id, scheduleData) => {
    try {
      console.log(`Mise √† jour du planning ${id}:`, scheduleData);
      const response = await apiRequest(
        `${API_ENDPOINTS.WEEKLY_SCHEDULES}/${id}`,
        "PUT",
        scheduleData
      );

      console.log(`R√©ponse de la mise √† jour du planning ${id}:`, response);

      // G√©rer les erreurs sp√©cifiques retourn√©es avec un code 4xx/5xx
      if (response && response.success === false) {
        console.error(
          `Erreur de mise √† jour du planning ${id}:`,
          response.message
        );
        return {
          success: false,
          message:
            response.message || "Erreur lors de la mise √† jour du planning",
          scheduleId: response.scheduleId, // Pour g√©rer le cas de conflit (planning existant)
        };
      }

      // En cas de succ√®s, la r√©ponse contient l'objet schedule
      if (response && response.schedule) {
        return { success: true, schedule: response.schedule };
      } else if (response && response.success) {
        // Si pas de schedule mais success=true
        return { success: true, schedule: response };
      }

      return { success: true, schedule: response }; // Par d√©faut, consid√©rer la r√©ponse comme le schedule
    } catch (error) {
      console.error(
        `Erreur d'API lors de la mise √† jour du planning ${id}:`,
        error
      );
      return {
        success: false,
        message: error.message || "Erreur lors de la mise √† jour du planning",
      };
    }
  },

  delete: async (id) => {
    try {
      console.log(`Suppression du planning ${id}...`);
      const response = await apiRequest(
        `${API_ENDPOINTS.WEEKLY_SCHEDULES}/${id}`,
        "DELETE"
      );

      console.log(`R√©ponse de la suppression du planning ${id}:`, response);

      // G√©rer les erreurs sp√©cifiques retourn√©es avec un code 4xx/5xx
      if (response && response.success === false) {
        console.error(
          `Erreur de suppression du planning ${id}:`,
          response.message
        );
        return {
          success: false,
          message:
            response.message || "Erreur lors de la suppression du planning",
        };
      }

      return { success: true };
    } catch (error) {
      console.error(
        `Erreur d'API lors de la suppression du planning ${id}:`,
        error
      );
      return {
        success: false,
        message: error.message || "Erreur lors de la suppression du planning",
      };
    }
  },
};

export const HourBalanceService = {
  getByEmployee: async (employeeId) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.HOUR_BALANCE.BY_EMPLOYEE(employeeId),
        "GET"
      );

      if (response && response.error) {
        return { success: false, message: response.error };
      }

      if (response && typeof response.balance !== "undefined") {
        return { success: true, balance: response.balance };
      }

      if (response && typeof response === "object") {
        if (typeof response.hour_balance !== "undefined") {
          return { success: true, balance: response.hour_balance };
        }

        if (
          Object.keys(response).length === 1 &&
          typeof Object.values(response)[0] === "number"
        ) {
          return { success: true, balance: Object.values(response)[0] };
        }
      }

      console.warn(
        `Avertissement: Format de r√©ponse inattendu pour le solde d'heures de l'employ√© ${employeeId}:`,
        response
      );
      return { success: true, balance: 0 };
    } catch (error) {
      console.warn(
        "Avertissement lors de la r√©cup√©ration du solde d'heures:",
        error
      );
      return {
        success: false,
        message:
          error.message || "Erreur lors de la r√©cup√©ration du solde d'heures",
      };
    }
  },

  updateBalance: async (employeeId, balanceData) => {
    try {
      const response = await apiRequest(
        API_ENDPOINTS.HOUR_BALANCE.BY_EMPLOYEE(employeeId),
        "PUT",
        balanceData
      );

      if (response && response.error) {
        return { success: false, message: response.error };
      }

      return {
        success: true,
        balance:
          response.balance ||
          response.hour_balance ||
          (typeof response === "number" ? response : 0),
      };
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du solde d'heures:", error);
      return {
        success: false,
        message:
          error.message || "Erreur lors de la mise √† jour du solde d'heures",
      };
    }
  },
};

export const NotificationService = {
  getNotifications: async (params = {}) => {
    try {
      // Construire l'URL avec les param√®tres de requ√™te
      let endpoint = API_ENDPOINTS.NOTIFICATIONS.BASE;
      if (params) {
        const queryParams = new URLSearchParams();
        for (const key in params) {
          if (params[key] !== undefined) {
            queryParams.append(key, params[key]);
          }
        }
        const queryString = queryParams.toString();
        if (queryString) {
          endpoint += `?${queryString}`;
        }
      }

      const url = `${API_URL}${endpoint}`;
      return await apiRequest(url, "GET");
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des notifications:", error);
      throw error;
    }
  },

  createNotification: async (notificationData) => {
    try {
      const url = `${API_URL}${API_ENDPOINTS.NOTIFICATIONS.BASE}`;
      return await apiRequest(url, "POST", notificationData);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation de la notification:", error);
      throw error;
    }
  },

  createBroadcastNotification: async (notificationData) => {
    try {
      const url = `${API_URL}${API_ENDPOINTS.NOTIFICATIONS.BASE}/broadcast`;
      return await apiRequest(url, "POST", notificationData);
    } catch (error) {
      console.error("Erreur lors de la diffusion des notifications:", error);
      throw error;
    }
  },

  getUnreadCount: async () => {
    try {
      const url = `${API_URL}${API_ENDPOINTS.NOTIFICATIONS.BASE}/unread-count`;
      return await apiRequest(url, "GET");
    } catch (error) {
      console.error(
        "Erreur lors de la r√©cup√©ration du nombre de notifications non lues:",
        error
      );
      throw error;
    }
  },

  markAsRead: async (notificationId) => {
    try {
      const url = `${API_URL}${API_ENDPOINTS.NOTIFICATIONS.MARK_READ(
        notificationId
      )}`;
      return await apiRequest(url, "PUT");
    } catch (error) {
      console.error(
        "Erreur lors du marquage de la notification comme lue:",
        error
      );
      throw error;
    }
  },

  markAllAsRead: async () => {
    try {
      const url = `${API_URL}${API_ENDPOINTS.NOTIFICATIONS.MARK_ALL_READ}`;
      return await apiRequest(url, "PUT");
    } catch (error) {
      console.error(
        "Erreur lors du marquage de toutes les notifications comme lues:",
        error
      );
      throw error;
    }
  },

  deleteNotification: async (notificationId) => {
    try {
      const url = `${API_URL}${API_ENDPOINTS.NOTIFICATIONS.BY_ID(
        notificationId
      )}`;
      return await apiRequest(url, "DELETE");
    } catch (error) {
      console.error("Erreur lors de la suppression de la notification:", error);
      throw error;
    }
  },

  deleteAllNotifications: async () => {
    try {
      const url = `${API_URL}${API_ENDPOINTS.NOTIFICATIONS.BASE}`;
      return await apiRequest(url, "DELETE");
    } catch (error) {
      console.error(
        "Erreur lors de la suppression de toutes les notifications:",
        error
      );
      throw error;
    }
  },
};

export const UserService = {
  getAll: async () => {
    try {
      const response = await apiRequest("GET", API_ENDPOINTS.USERS);
      return normalizeResponse(response);
    } catch (error) {
      console.error("Erreur UserService.getAll:", error);
      return {
        success: false,
        error: formatError(error),
        message: formatError(error),
      };
    }
  },
};
