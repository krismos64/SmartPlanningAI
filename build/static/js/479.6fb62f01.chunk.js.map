{"version":3,"file":"static/js/479.6fb62f01.chunk.js","mappings":"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","sources":["hooks/useEmployees.js","hooks/useApi.js"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { API_ENDPOINTS, API_URL } from \"../config/api\";\nimport useApi from \"./useApi\";\n\n/**\n * Hook personnalisé pour gérer les employés\n */\nconst useEmployees = () => {\n  const [employees, setEmployees] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const api = useApi();\n  // Référence pour suivre si le composant est monté\n  const isMountedRef = useRef(true);\n  // Référence pour éviter les appels multiples simultanés\n  const isFetchingRef = useRef(false);\n\n  // Marquer le composant comme monté/démonté\n  useEffect(() => {\n    // Réinitialiser l'état au montage\n    isMountedRef.current = true;\n    isFetchingRef.current = false;\n\n    return () => {\n      // Marquer comme démonté pour éviter les mises à jour d'état après démontage\n      isMountedRef.current = false;\n      // Réinitialiser les références au démontage\n      isFetchingRef.current = false;\n    };\n  }, []);\n\n  /**\n   * Récupère tous les employés depuis l'API\n   */\n  const fetchEmployees = useCallback(async () => {\n    // Éviter les appels API multiples simultanés\n    if (isFetchingRef.current || !isMountedRef.current) {\n      return;\n    }\n\n    isFetchingRef.current = true;\n    setLoading(true);\n\n    try {\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[fetchEmployees] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors du chargement des employés\"\n        );\n      }\n\n      const data = await response.json();\n\n      // Vérifier si le composant est toujours monté avant de mettre à jour l'état\n      if (isMountedRef.current) {\n        setEmployees(Array.isArray(data) ? data : []);\n        setError(null);\n      }\n\n      return data;\n    } catch (error) {\n      console.error(\"Erreur lors du chargement des employés:\", error);\n\n      // Vérifier si le composant est toujours monté avant de mettre à jour l'état\n      if (isMountedRef.current) {\n        setError(error.message);\n      }\n\n      throw error;\n    } finally {\n      // Vérifier si le composant est toujours monté avant de mettre à jour l'état\n      if (isMountedRef.current) {\n        setLoading(false);\n      }\n\n      isFetchingRef.current = false;\n    }\n  }, []);\n\n  /**\n   * Récupère un employé par son ID\n   */\n  const fetchEmployeeById = useCallback(async (id) => {\n    if (!isMountedRef.current) return null;\n\n    setLoading(true);\n    try {\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[fetchEmployeeById] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees/${id}`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors du chargement de l'employé\"\n        );\n      }\n\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error(\n        `Erreur lors de la récupération de l'employé ${id}:`,\n        error\n      );\n      if (isMountedRef.current) {\n        setError(error.message);\n      }\n      return null;\n    } finally {\n      if (isMountedRef.current) {\n        setLoading(false);\n      }\n    }\n  }, []);\n\n  /**\n   * Crée un nouvel employé\n   */\n  const createEmployee = useCallback(async (employeeData) => {\n    if (!isMountedRef.current) return { success: false };\n\n    setLoading(true);\n    try {\n      // Supprimer hourlyRate des données pour éviter l'erreur\n      const { hourlyRate, ...cleanedData } = employeeData;\n\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[createEmployee] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // S'assurer que les données sont sérialisables\n      const jsonData = JSON.parse(JSON.stringify(cleanedData));\n\n      // Convertir les données en snake_case pour le backend\n      const snakeCaseData = {};\n      for (const key in jsonData) {\n        if (key === \"zipCode\") {\n          snakeCaseData[\"zip_code\"] = jsonData[key];\n        } else {\n          snakeCaseData[\n            key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n          ] = jsonData[key];\n        }\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n        body: JSON.stringify(snakeCaseData),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors de la création de l'employé\"\n        );\n      }\n\n      const data = await response.json();\n\n      // Mettre à jour la liste des employés\n      if (isMountedRef.current) {\n        setEmployees((prevEmployees) => [\n          ...prevEmployees,\n          data.employee || data,\n        ]);\n        setError(null);\n      }\n\n      return {\n        success: true,\n        employee: data.employee || data,\n        message: \"Employé créé avec succès\",\n      };\n    } catch (error) {\n      console.error(\"Erreur lors de la création de l'employé:\", error);\n      if (isMountedRef.current) {\n        setError(error.message);\n      }\n      return {\n        success: false,\n        error: error.message || \"Erreur lors de la création de l'employé\",\n      };\n    } finally {\n      if (isMountedRef.current) {\n        setLoading(false);\n      }\n    }\n  }, []);\n\n  /**\n   * Met à jour un employé existant\n   */\n  const updateEmployee = useCallback(async (id, employeeData) => {\n    if (!isMountedRef.current) return { success: false };\n\n    setLoading(true);\n    try {\n      // Supprimer hourlyRate des données pour éviter l'erreur\n      const { hourlyRate, ...cleanedData } = employeeData;\n\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[updateEmployee] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // S'assurer que les données sont sérialisables\n      const jsonData = JSON.parse(JSON.stringify(cleanedData));\n\n      // Convertir les données en snake_case pour le backend\n      const snakeCaseData = {};\n      for (const key in jsonData) {\n        if (key === \"zipCode\") {\n          snakeCaseData[\"zip_code\"] = jsonData[key];\n        } else {\n          snakeCaseData[\n            key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n          ] = jsonData[key];\n        }\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees/${id}`, {\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n        body: JSON.stringify(snakeCaseData),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors de la mise à jour de l'employé\"\n        );\n      }\n\n      const data = await response.json();\n\n      // Mettre à jour la liste des employés\n      if (isMountedRef.current) {\n        setEmployees((prevEmployees) =>\n          prevEmployees.map((emp) =>\n            emp.id === id ? { ...emp, ...(data.employee || data) } : emp\n          )\n        );\n      }\n\n      return {\n        success: true,\n        message: \"Employé mis à jour avec succès\",\n        data: data.employee || data,\n      };\n    } catch (error) {\n      console.error(\"Erreur lors de la mise à jour de l'employé:\", error);\n      if (isMountedRef.current) {\n        setError(error.message);\n      }\n      return {\n        success: false,\n        error: error.message || \"Erreur lors de la mise à jour de l'employé\",\n      };\n    } finally {\n      if (isMountedRef.current) {\n        setLoading(false);\n      }\n    }\n  }, []);\n\n  /**\n   * Supprime un employé\n   */\n  const deleteEmployee = useCallback(async (id) => {\n    if (!isMountedRef.current) return { success: false };\n\n    setLoading(true);\n    try {\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[deleteEmployee] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees/${id}`, {\n        method: \"DELETE\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors de la suppression de l'employé\"\n        );\n      }\n\n      // Mettre à jour la liste des employés\n      if (isMountedRef.current) {\n        setEmployees((prevEmployees) =>\n          prevEmployees.filter((emp) => emp.id !== id)\n        );\n      }\n\n      return {\n        success: true,\n        message: \"Employé supprimé avec succès\",\n      };\n    } catch (error) {\n      console.error(`Erreur lors de la suppression de l'employé ${id}:`, error);\n      if (isMountedRef.current) {\n        setError(error.message);\n      }\n      return {\n        success: false,\n        error: error.message || \"Erreur lors de la suppression de l'employé\",\n      };\n    } finally {\n      if (isMountedRef.current) {\n        setLoading(false);\n      }\n    }\n  }, []);\n\n  /**\n   * Filtre les employés par statut\n   * @param {string|null} status - Le statut à filtrer (active, inactive, vacation, sick) ou null pour tous\n   * @returns {Array} - Les employés filtrés\n   */\n  const getEmployeesByStatus = useCallback(\n    (status) => {\n      if (!status || status === \"all\") return employees;\n      return employees.filter((employee) => employee.status === status);\n    },\n    [employees]\n  );\n\n  /**\n   * Récupère le solde d'heures d'un employé\n   */\n  const fetchEmployeeHourBalance = useCallback(\n    async (id) => {\n      if (!isMountedRef.current) return 0;\n\n      try {\n        // Ajouter un délai aléatoire pour éviter les requêtes simultanées\n        const randomDelay = Math.floor(Math.random() * 200);\n        await new Promise((resolve) => setTimeout(resolve, randomDelay));\n\n        const response = await api.get(`/api/hour-balance/${id}`);\n\n        // Vérifier si la réponse contient hour_balance ou balance\n        if (\n          response &&\n          (response.hour_balance !== undefined ||\n            response.balance !== undefined)\n        ) {\n          const balance =\n            response.hour_balance !== undefined\n              ? response.hour_balance\n              : response.balance;\n\n          // Mettre à jour l'état local des employés avec le nouveau solde d'heures\n          if (isMountedRef.current) {\n            setEmployees((prev) =>\n              prev.map((emp) =>\n                emp.id === id ? { ...emp, hour_balance: balance } : emp\n              )\n            );\n          }\n          return balance;\n        } else {\n          console.warn(\n            `Avertissement: Format de réponse inattendu pour l'employé #${id}`\n          );\n          return 0; // Retourner 0 par défaut\n        }\n      } catch (err) {\n        // Éviter de logger l'erreur complète pour ne pas surcharger la console\n        console.warn(\n          `Avertissement: Impossible de récupérer le solde d'heures pour l'employé #${id}`\n        );\n\n        // Ne pas mettre à jour l'état pour éviter des re-rendus en cascade\n        return 0; // Retourner 0 par défaut en cas d'erreur\n      }\n    },\n    [api]\n  );\n\n  /**\n   * Récupère le solde d'heures pour tous les employés\n   * Utilise une approche séquentielle pour éviter de surcharger le navigateur\n   */\n  const fetchAllEmployeesHourBalances = useCallback(async () => {\n    if (!isMountedRef.current) return;\n\n    // Variable pour suivre si la fonction est déjà en cours d'exécution\n    if (window._isFetchingHourBalances) {\n      return;\n    }\n\n    try {\n      // Marquer comme en cours d'exécution\n      window._isFetchingHourBalances = true;\n\n      // Traiter les employés un par un au lieu de par lots\n      for (const employee of employees) {\n        if (!isMountedRef.current) break; // Arrêter si le composant est démonté\n\n        try {\n          await fetchEmployeeHourBalance(employee.id);\n          // Attendre 300ms entre chaque requête\n          await new Promise((resolve) => setTimeout(resolve, 300));\n        } catch (error) {\n          // Ignorer les erreurs individuelles et continuer avec le prochain employé\n          console.warn(\n            `Erreur pour l'employé ${employee.id}, continuons avec le suivant`\n          );\n        }\n      }\n    } catch (err) {\n      console.error(\"Erreur lors de la récupération des soldes d'heures:\", err);\n    } finally {\n      // Marquer comme terminé\n      window._isFetchingHourBalances = false;\n    }\n  }, [employees, fetchEmployeeHourBalance]);\n\n  // Charger les employés depuis l'API\n  useEffect(() => {\n    let retryCount = 0;\n    const maxRetries = 2;\n\n    // Fonction pour charger les employés - le cache local a été supprimé pour éviter les bugs\n    const loadEmployees = async () => {\n      if (retryCount >= maxRetries || !isMountedRef.current) {\n        if (isMountedRef.current) {\n          setError(\n            \"Erreur lors du chargement des employés après plusieurs tentatives\"\n          );\n          setLoading(false);\n        }\n        return;\n      }\n\n      try {\n        const token = localStorage.getItem(\"token\");\n\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          if (isMountedRef.current) {\n            setError(\"Vous devez être connecté pour accéder à ces données\");\n            setLoading(false);\n          }\n          return;\n        }\n\n        const data = await api.get(API_ENDPOINTS.EMPLOYEES.BASE);\n\n        if (isMountedRef.current) {\n          if (Array.isArray(data)) {\n            setEmployees(data);\n            setError(null);\n            // Le cache local a été supprimé pour éviter les problèmes au rechargement\n          } else {\n            console.error(\"Format de données invalide:\", data);\n            setError(\"Format de données invalide\");\n          }\n          setLoading(false);\n        }\n      } catch (err) {\n        if (isMountedRef.current) {\n          console.error(\"Erreur lors du chargement des employés:\", err);\n          setError(err.message || \"Erreur lors du chargement des employés\");\n\n          // Réessayer avec un délai exponentiel\n          retryCount++;\n          setTimeout(loadEmployees, 1000 * Math.pow(2, retryCount));\n        }\n      }\n    };\n\n    // Charger les employés uniquement si le composant est monté\n    if (isMountedRef.current) {\n      loadEmployees();\n    }\n\n    // Nettoyer lors du démontage\n    return () => {\n      // Le nettoyage est géré dans le premier useEffect\n    };\n  }, [api]);\n\n  // Charger les soldes d'heures après avoir chargé les employés\n  // Utiliser une référence pour suivre si l'effet a déjà été exécuté\n  const hourBalancesLoaded = useRef(false);\n\n  useEffect(() => {\n    // Ne charger les soldes d'heures que si les employés sont chargés, que l'effet n'a pas encore été exécuté\n    // et que le composant est toujours monté\n    if (\n      employees.length > 0 &&\n      !hourBalancesLoaded.current &&\n      isMountedRef.current\n    ) {\n      // Marquer l'effet comme exécuté\n      hourBalancesLoaded.current = true;\n\n      // Ajouter un délai avant de charger les soldes d'heures\n      // pour s'assurer que le composant est complètement monté\n      const timer = setTimeout(() => {\n        if (isMountedRef.current) {\n          fetchAllEmployeesHourBalances();\n        }\n      }, 1000);\n\n      return () => clearTimeout(timer);\n    }\n  }, [employees.length, fetchAllEmployeesHourBalances]);\n\n  return {\n    employees,\n    loading,\n    error,\n    fetchEmployees,\n    fetchEmployeeById,\n    createEmployee,\n    updateEmployee,\n    deleteEmployee,\n    getEmployeesByStatus,\n    fetchEmployeeHourBalance,\n    fetchAllEmployeesHourBalances,\n  };\n};\n\nexport default useEmployees;\n","import { useCallback, useMemo } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { API_URL } from \"../config/api\";\n\n/**\n * Hook personnalisé pour effectuer des appels API\n * @returns {Object} Méthodes pour effectuer des requêtes API\n */\nconst useApi = () => {\n  const handleResponse = useCallback(async (response) => {\n    try {\n      // Récupérer les en-têtes pour le débogage\n      const headers = {};\n      response.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      console.log(\"Réponse du serveur:\", {\n        url: response.url,\n        status: response.status,\n        statusText: response.statusText,\n        headers: headers,\n      });\n\n      // Vérifier si la réponse est au format JSON\n      const contentType = response.headers.get(\"content-type\");\n      const isJson = contentType && contentType.includes(\"application/json\");\n\n      // Récupérer le corps de la réponse\n      let data;\n      if (isJson) {\n        data = await response.json();\n        console.log(\"Données JSON reçues:\", data);\n      } else {\n        const text = await response.text();\n        console.warn(\"Réponse non-JSON reçue:\", text);\n        try {\n          // Essayer de parser le texte comme JSON\n          data = JSON.parse(text);\n          console.log(\"Texte parsé comme JSON:\", data);\n        } catch (e) {\n          data = { message: text };\n        }\n      }\n\n      // Gérer les différents codes de statut\n      if (response.ok) {\n        return data;\n      } else {\n        // Gérer les erreurs d'authentification (401, 403)\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", data);\n\n          // Afficher un message d'erreur mais ne pas rediriger\n          toast.error(\n            \"Session expirée ou accès non autorisé. Veuillez vous reconnecter.\"\n          );\n\n          // Ne pas supprimer le token et l'utilisateur du localStorage\n          // Ne pas rediriger vers la page de connexion\n\n          // Lancer une erreur avec un message clair\n          const error = new Error(\n            \"Veuillez vous connecter pour accéder à cette page.\"\n          );\n          error.status = response.status;\n          error.response = { status: response.status, data };\n          throw error;\n        }\n\n        // Gérer les erreurs serveur (500)\n        if (response.status === 500) {\n          console.error(\"Erreur serveur:\", data);\n          console.error(\"URL:\", response.url);\n          console.error(\"Méthode:\", response.method);\n\n          // Journaliser plus de détails pour le débogage\n          if (data.error) {\n            console.error(\"Détails de l'erreur:\", data.error);\n          }\n          if (data.stack) {\n            console.error(\"Stack trace:\", data.stack);\n          }\n        }\n\n        // Construire un message d'erreur détaillé\n        const errorMessage =\n          data.message ||\n          data.error ||\n          response.statusText ||\n          \"Erreur inconnue\";\n        const error = new Error(errorMessage);\n        error.status = response.status;\n        error.response = { status: response.status, data };\n\n        throw error;\n      }\n    } catch (error) {\n      console.error(\"Erreur lors du traitement de la réponse:\", error);\n      throw error;\n    }\n  }, []);\n\n  const api = useMemo(() => {\n    const get = async (endpoint) => {\n      try {\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5001\"; // Utiliser l'URL correcte\n        console.log(`[API] GET ${apiUrl}${endpoint}`);\n\n        // Gestion spéciale pour les départements - ne pas afficher d'erreurs\n        const isDepartmentsEndpoint = endpoint.includes(\"/departments\");\n\n        const token = localStorage.getItem(\"token\");\n        const headers = {\n          \"Content-Type\": \"application/json\",\n          ...(token && { Authorization: `Bearer ${token}` }),\n        };\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"GET\",\n          headers,\n        });\n\n        // Pour les requêtes autres que les départements, vérifier si la réponse est OK\n        if (!isDepartmentsEndpoint && !response.ok) {\n          const errorData = await response.json();\n          throw new Error(\n            errorData.message || `Erreur lors de la requête GET ${endpoint}`\n          );\n        }\n\n        const result = await handleResponse(response);\n\n        // Pour les départements, on retourne un objet structuré\n        if (isDepartmentsEndpoint) {\n          return {\n            ok: response.ok,\n            status: response.status,\n            data: result,\n            headers: response.headers,\n          };\n        }\n\n        // Pour les autres requêtes, on retourne directement les données\n        return result;\n      } catch (error) {\n        console.error(`[API] GET ${endpoint} Error:`, error);\n\n        // Vérifier si c'est une requête pour les départements\n        const isDepartmentsEndpoint = endpoint.includes(\"/departments\");\n\n        // Si c'est une requête pour les départements, retourner un objet structuré\n        if (isDepartmentsEndpoint) {\n          console.log(\"Erreur silencieuse pour les départements\");\n          return {\n            ok: false,\n            status: error.status || 0,\n            data: { message: error.message || \"Erreur lors de la requête GET\" },\n            headers: new Headers(),\n          };\n        }\n\n        // Pour les autres requêtes, propager l'erreur\n        throw error;\n      }\n    };\n\n    // Fonction utilitaire pour convertir camelCase en snake_case\n    const camelToSnakeCase = (str) => {\n      // Cas spécial pour zipCode qui doit devenir zip_code\n      if (str === \"zipCode\") {\n        console.log(`Conversion spéciale: ${str} -> zip_code`);\n        return \"zip_code\";\n      }\n\n      // Conversion normale\n      const result = str.replace(\n        /[A-Z]/g,\n        (letter) => `_${letter.toLowerCase()}`\n      );\n      console.log(`Conversion camelCase -> snake_case: ${str} -> ${result}`);\n      return result;\n    };\n\n    const post = async (endpoint, data) => {\n      try {\n        // Vérifier que les données sont valides\n        if (!data || typeof data !== \"object\") {\n          console.error(\"Données invalides pour la requête POST:\", data);\n          throw new Error(\"Données invalides pour la requête POST\");\n        }\n\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5001\"; // Utiliser l'URL correcte\n        console.log(`[API] POST ${apiUrl}${endpoint}`);\n\n        // Vérifier si le token est présent\n        const token = localStorage.getItem(\"token\");\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        // S'assurer que les données sont sérialisables\n        const cleanData = JSON.parse(JSON.stringify(data));\n\n        // Supprimer hourlyRate des données pour éviter l'erreur\n        if (cleanData.hourlyRate !== undefined) {\n          console.log(\"Suppression de hourlyRate des données\");\n          delete cleanData.hourlyRate;\n        }\n\n        // Convertir les données en snake_case pour le backend\n        const snakeCaseData = {};\n        for (const key in cleanData) {\n          snakeCaseData[camelToSnakeCase(key)] = cleanData[key];\n        }\n        console.log(\n          \"Données converties en snake_case pour POST:\",\n          snakeCaseData\n        );\n\n        // Configurer les en-têtes de la requête\n        const headers = {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        };\n\n        // Journaliser les détails de la requête (sans le token complet)\n        console.log(\"Détails de la requête POST:\", {\n          endpoint,\n          dataSize: JSON.stringify(snakeCaseData).length,\n          headers: { ...headers, Authorization: \"Bearer [MASQUÉ]\" },\n        });\n\n        // Effectuer la requête avec un timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondes de timeout\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(snakeCaseData),\n          signal: controller.signal,\n        });\n\n        // Annuler le timeout\n        clearTimeout(timeoutId);\n\n        // Vérifier si la réponse est une erreur d'authentification\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", response.status);\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        // Traiter la réponse\n        return handleResponse(response);\n      } catch (error) {\n        // Gérer les erreurs spécifiques\n        if (error.name === \"AbortError\") {\n          console.error(\"La requête a été interrompue (timeout):\", error);\n          throw new Error(\n            \"La requête a pris trop de temps. Veuillez réessayer.\"\n          );\n        }\n\n        if (\n          error.message.includes(\"NetworkError\") ||\n          error.message.includes(\"Failed to fetch\")\n        ) {\n          console.error(\"Erreur réseau lors de la requête POST:\", error);\n          throw new Error(\n            \"Problème de connexion au serveur, veuillez vérifier votre connexion internet\"\n          );\n        }\n\n        // Journaliser et propager l'erreur\n        console.error(\"Erreur lors de la requête POST:\", error);\n        throw error;\n      }\n    };\n\n    const put = async (endpoint, data) => {\n      try {\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5001\"; // Utiliser l'URL correcte\n        console.log(`[API] PUT ${apiUrl}${endpoint}`, data);\n\n        const token = localStorage.getItem(\"token\");\n\n        // Vérifier si le token est présent\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        // S'assurer que les données sont sérialisables\n        const cleanData = JSON.parse(JSON.stringify(data));\n        console.log(\"Données nettoyées:\", cleanData);\n\n        // Supprimer hourlyRate des données pour éviter l'erreur\n        if (cleanData.hourlyRate !== undefined) {\n          console.log(\"Suppression de hourlyRate des données\");\n          delete cleanData.hourlyRate;\n        }\n\n        // Convertir les données en snake_case pour le backend\n        const snakeCaseData = {};\n        for (const key in cleanData) {\n          snakeCaseData[camelToSnakeCase(key)] = cleanData[key];\n        }\n        console.log(\"Données converties en snake_case:\", snakeCaseData);\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"PUT\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n          body: JSON.stringify(snakeCaseData),\n        });\n\n        // Vérifier si la réponse est une erreur d'authentification\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", response.status);\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        const result = await handleResponse(response);\n        console.log(`[API] PUT ${endpoint} Response:`, result);\n        return result;\n      } catch (error) {\n        console.error(`[API] PUT ${endpoint} Error:`, error);\n\n        // Ne pas rediriger automatiquement vers la page de connexion\n        // Laisser le composant gérer l'erreur\n\n        return {\n          ok: false,\n          status: error.status || 0,\n          data: { message: error.message || \"Erreur lors de la requête PUT\" },\n          headers: new Headers(),\n        };\n      }\n    };\n\n    const del = async (endpoint) => {\n      try {\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5004\"; // Forcer l'URL correcte\n        console.log(`[API] DELETE ${apiUrl}${endpoint}`);\n\n        const token = localStorage.getItem(\"token\");\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"DELETE\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n        });\n\n        // Vérifier si la réponse est une erreur d'authentification\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", response.status);\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        const result = await handleResponse(response);\n        console.log(`[API] DELETE ${endpoint} Response:`, result);\n        return result;\n      } catch (error) {\n        console.error(`[API] DELETE ${endpoint} Error:`, error);\n        return {\n          ok: false,\n          status: error.status || 0,\n          data: {\n            message: error.message || \"Erreur lors de la requête DELETE\",\n          },\n          headers: new Headers(),\n        };\n      }\n    };\n\n    return {\n      get,\n      post,\n      put,\n      delete: del,\n    };\n  }, [handleResponse]);\n\n  return api;\n};\n\nexport default useApi;\n"],"names":["useEmployees","employees","setEmployees","useState","loading","setLoading","error","setError","api","useApi","isMountedRef","useRef","isFetchingRef","useEffect","current","fetchEmployees","useCallback","async","apiUrl","API_URL","console","log","token","localStorage","getItem","Error","response","fetch","method","headers","Authorization","ok","errorData","json","message","data","Array","isArray","fetchEmployeeById","id","createEmployee","success","hourlyRate","cleanedData","employeeData","jsonData","JSON","parse","stringify","snakeCaseData","key","replace","letter","toLowerCase","body","prevEmployees","employee","updateEmployee","map","emp","deleteEmployee","filter","getEmployeesByStatus","status","fetchEmployeeHourBalance","randomDelay","Math","floor","random","Promise","resolve","setTimeout","get","undefined","hour_balance","balance","warn","prev","err","fetchAllEmployeesHourBalances","window","_isFetchingHourBalances","retryCount","loadEmployees","API_ENDPOINTS","EMPLOYEES","BASE","pow","hourBalancesLoaded","length","timer","clearTimeout","handleResponse","forEach","value","url","statusText","contentType","includes","text","e","toast","stack","errorMessage","useMemo","camelToSnakeCase","str","result","endpoint","isDepartmentsEndpoint","Headers","post","cleanData","dataSize","controller","AbortController","timeoutId","abort","signal","name","put","delete"],"sourceRoot":""}