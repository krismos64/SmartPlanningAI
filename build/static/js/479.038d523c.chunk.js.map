{"version":3,"file":"static/js/479.038d523c.chunk.js","mappings":"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","sources":["hooks/useEmployees.js","hooks/useApi.js"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { API_ENDPOINTS, API_URL } from \"../config/api\";\nimport useApi from \"./useApi\";\n\n/**\n * Hook personnalisé pour gérer les employés\n */\nconst useEmployees = () => {\n  const [employees, setEmployees] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const api = useApi();\n\n  /**\n   * Récupère tous les employés depuis l'API\n   */\n  const fetchEmployees = useCallback(async () => {\n    setLoading(true);\n    try {\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[fetchEmployees] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors du chargement des employés\"\n        );\n      }\n\n      const data = await response.json();\n      setEmployees(Array.isArray(data) ? data : []);\n      setError(null);\n      return data;\n    } catch (error) {\n      console.error(\"Erreur lors du chargement des employés:\", error);\n      setError(error.message);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  /**\n   * Récupère un employé par son ID\n   */\n  const fetchEmployeeById = useCallback(async (id) => {\n    setLoading(true);\n    try {\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[fetchEmployeeById] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees/${id}`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors du chargement de l'employé\"\n        );\n      }\n\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error(\n        `Erreur lors de la récupération de l'employé ${id}:`,\n        error\n      );\n      setError(error.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  /**\n   * Crée un nouvel employé\n   */\n  const createEmployee = useCallback(async (employeeData) => {\n    setLoading(true);\n    try {\n      // Supprimer hourlyRate des données pour éviter l'erreur\n      const { hourlyRate, ...cleanedData } = employeeData;\n\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[createEmployee] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // S'assurer que les données sont sérialisables\n      const jsonData = JSON.parse(JSON.stringify(cleanedData));\n\n      // Convertir les données en snake_case pour le backend\n      const snakeCaseData = {};\n      for (const key in jsonData) {\n        if (key === \"zipCode\") {\n          snakeCaseData[\"zip_code\"] = jsonData[key];\n        } else {\n          snakeCaseData[\n            key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n          ] = jsonData[key];\n        }\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n        body: JSON.stringify(snakeCaseData),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors de la création de l'employé\"\n        );\n      }\n\n      const data = await response.json();\n\n      // Mettre à jour la liste des employés\n      setEmployees((prevEmployees) => [\n        ...prevEmployees,\n        data.employee || data,\n      ]);\n      setError(null);\n\n      return {\n        success: true,\n        employee: data.employee || data,\n        message: \"Employé créé avec succès\",\n      };\n    } catch (error) {\n      console.error(\"Erreur lors de la création de l'employé:\", error);\n      setError(error.message);\n      return {\n        success: false,\n        error: error.message || \"Erreur lors de la création de l'employé\",\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  /**\n   * Met à jour un employé existant\n   */\n  const updateEmployee = useCallback(async (id, employeeData) => {\n    setLoading(true);\n    try {\n      // Supprimer hourlyRate des données pour éviter l'erreur\n      const { hourlyRate, ...cleanedData } = employeeData;\n\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[updateEmployee] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // S'assurer que les données sont sérialisables\n      const jsonData = JSON.parse(JSON.stringify(cleanedData));\n\n      // Convertir les données en snake_case pour le backend\n      const snakeCaseData = {};\n      for (const key in jsonData) {\n        if (key === \"zipCode\") {\n          snakeCaseData[\"zip_code\"] = jsonData[key];\n        } else {\n          snakeCaseData[\n            key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n          ] = jsonData[key];\n        }\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees/${id}`, {\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n        body: JSON.stringify(snakeCaseData),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors de la mise à jour de l'employé\"\n        );\n      }\n\n      const data = await response.json();\n\n      // Mettre à jour la liste des employés\n      setEmployees((prevEmployees) =>\n        prevEmployees.map((emp) =>\n          emp.id === id ? { ...emp, ...(data.employee || data) } : emp\n        )\n      );\n\n      return {\n        success: true,\n        message: \"Employé mis à jour avec succès\",\n        data: data.employee || data,\n      };\n    } catch (error) {\n      console.error(\"Erreur lors de la mise à jour de l'employé:\", error);\n      setError(error.message);\n      return {\n        success: false,\n        error: error.message || \"Erreur lors de la mise à jour de l'employé\",\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  /**\n   * Supprime un employé\n   */\n  const deleteEmployee = useCallback(async (id) => {\n    setLoading(true);\n    try {\n      // Forcer l'URL correcte\n      const apiUrl = API_URL || \"http://localhost:5004\";\n      console.log(`[deleteEmployee] Utilisation de l'URL: ${apiUrl}`);\n\n      // Vérifier si le token est présent\n      const token = localStorage.getItem(\"token\");\n      if (!token) {\n        throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n      }\n\n      // Utiliser fetch directement avec l'URL correcte\n      const response = await fetch(`${apiUrl}/api/employees/${id}`, {\n        method: \"DELETE\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(\n          errorData.message || \"Erreur lors de la suppression de l'employé\"\n        );\n      }\n\n      // Mettre à jour la liste des employés\n      setEmployees((prevEmployees) =>\n        prevEmployees.filter((emp) => emp.id !== id)\n      );\n\n      return {\n        success: true,\n        message: \"Employé supprimé avec succès\",\n      };\n    } catch (error) {\n      console.error(`Erreur lors de la suppression de l'employé ${id}:`, error);\n      setError(error.message);\n      return {\n        success: false,\n        error: error.message || \"Erreur lors de la suppression de l'employé\",\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  /**\n   * Filtre les employés par statut\n   * @param {string|null} status - Le statut à filtrer (active, inactive, vacation, sick) ou null pour tous\n   * @returns {Array} - Les employés filtrés\n   */\n  const getEmployeesByStatus = useCallback(\n    (status) => {\n      if (!status || status === \"all\") return employees;\n      return employees.filter((employee) => employee.status === status);\n    },\n    [employees]\n  );\n\n  /**\n   * Récupère le solde d'heures d'un employé\n   */\n  const fetchEmployeeHourBalance = useCallback(\n    async (id) => {\n      try {\n        // Ajouter un délai aléatoire pour éviter les requêtes simultanées\n        const randomDelay = Math.floor(Math.random() * 200);\n        await new Promise((resolve) => setTimeout(resolve, randomDelay));\n\n        const response = await api.get(`/api/hour-balance/${id}`);\n\n        // Vérifier si la réponse contient hour_balance ou balance\n        if (\n          response &&\n          (response.hour_balance !== undefined ||\n            response.balance !== undefined)\n        ) {\n          const balance =\n            response.hour_balance !== undefined\n              ? response.hour_balance\n              : response.balance;\n\n          // Mettre à jour l'état local des employés avec le nouveau solde d'heures\n          setEmployees((prev) =>\n            prev.map((emp) =>\n              emp.id === id ? { ...emp, hour_balance: balance } : emp\n            )\n          );\n          return balance;\n        } else {\n          console.warn(\n            `Avertissement: Format de réponse inattendu pour l'employé #${id}`\n          );\n          return 0; // Retourner 0 par défaut\n        }\n      } catch (err) {\n        // Éviter de logger l'erreur complète pour ne pas surcharger la console\n        console.warn(\n          `Avertissement: Impossible de récupérer le solde d'heures pour l'employé #${id}`\n        );\n\n        // Ne pas mettre à jour l'état pour éviter des re-rendus en cascade\n        return 0; // Retourner 0 par défaut en cas d'erreur\n      }\n    },\n    [api, setEmployees]\n  );\n\n  /**\n   * Récupère le solde d'heures pour tous les employés\n   * Utilise une approche séquentielle pour éviter de surcharger le navigateur\n   */\n  const fetchAllEmployeesHourBalances = useCallback(async () => {\n    // Variable pour suivre si la fonction est déjà en cours d'exécution\n    if (window._isFetchingHourBalances) {\n      return;\n    }\n\n    try {\n      // Marquer comme en cours d'exécution\n      window._isFetchingHourBalances = true;\n\n      // Traiter les employés un par un au lieu de par lots\n      for (const employee of employees) {\n        try {\n          await fetchEmployeeHourBalance(employee.id);\n          // Attendre 300ms entre chaque requête\n          await new Promise((resolve) => setTimeout(resolve, 300));\n        } catch (error) {\n          // Ignorer les erreurs individuelles et continuer avec le prochain employé\n          console.warn(\n            `Erreur pour l'employé ${employee.id}, continuons avec le suivant`\n          );\n        }\n      }\n    } catch (err) {\n      console.error(\"Erreur lors de la récupération des soldes d'heures:\", err);\n    } finally {\n      // Marquer comme terminé\n      window._isFetchingHourBalances = false;\n    }\n  }, [employees, fetchEmployeeHourBalance]);\n\n  // Charger les employés au montage du composant\n  useEffect(() => {\n    let mounted = true;\n    let retryCount = 0;\n    const maxRetries = 3;\n\n    const loadEmployees = async () => {\n      if (retryCount >= maxRetries) {\n        if (mounted) {\n          setError(\n            \"Erreur lors du chargement des employés après plusieurs tentatives\"\n          );\n          setLoading(false);\n        }\n        return;\n      }\n\n      try {\n        const token = localStorage.getItem(\"token\");\n\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          setError(\"Vous devez être connecté pour accéder à ces données\");\n          setLoading(false);\n          return;\n        }\n\n        const data = await api.get(API_ENDPOINTS.EMPLOYEES.BASE);\n\n        if (mounted) {\n          if (Array.isArray(data)) {\n            setEmployees(data);\n            setError(null);\n          } else {\n            console.error(\"Format de données invalide:\", data);\n            setError(\"Format de données invalide\");\n          }\n          setLoading(false);\n        }\n      } catch (err) {\n        if (mounted) {\n          console.error(\"Erreur lors du chargement des employés:\", err);\n          setError(err.message || \"Erreur lors du chargement des employés\");\n\n          // Réessayer avec un délai exponentiel\n          retryCount++;\n          setTimeout(loadEmployees, 1000 * Math.pow(2, retryCount));\n        }\n      }\n    };\n\n    loadEmployees();\n\n    return () => {\n      mounted = false;\n    };\n  }, [api]);\n\n  // Charger les soldes d'heures après avoir chargé les employés\n  // Utiliser une référence pour suivre si l'effet a déjà été exécuté\n  const hourBalancesLoaded = useRef(false);\n\n  useEffect(() => {\n    // Ne charger les soldes d'heures que si les employés sont chargés et que l'effet n'a pas encore été exécuté\n    if (employees.length > 0 && !hourBalancesLoaded.current) {\n      // Marquer l'effet comme exécuté\n      hourBalancesLoaded.current = true;\n\n      // Ajouter un délai avant de charger les soldes d'heures\n      // pour s'assurer que le composant est complètement monté\n      const timer = setTimeout(() => {\n        fetchAllEmployeesHourBalances();\n      }, 1000);\n\n      return () => clearTimeout(timer);\n    }\n  }, [employees.length, fetchAllEmployeesHourBalances]);\n\n  return {\n    employees,\n    loading,\n    error,\n    fetchEmployees,\n    fetchEmployeeById,\n    createEmployee,\n    updateEmployee,\n    deleteEmployee,\n    getEmployeesByStatus,\n    fetchEmployeeHourBalance,\n    fetchAllEmployeesHourBalances,\n  };\n};\n\nexport default useEmployees;\n","import { useCallback, useMemo } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { API_URL } from \"../config/api\";\n\n/**\n * Hook personnalisé pour effectuer des appels API\n * @returns {Object} Méthodes pour effectuer des requêtes API\n */\nconst useApi = () => {\n  const handleResponse = useCallback(async (response) => {\n    try {\n      // Récupérer les en-têtes pour le débogage\n      const headers = {};\n      response.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      console.log(\"Réponse du serveur:\", {\n        url: response.url,\n        status: response.status,\n        statusText: response.statusText,\n        headers: headers,\n      });\n\n      // Vérifier si la réponse est au format JSON\n      const contentType = response.headers.get(\"content-type\");\n      const isJson = contentType && contentType.includes(\"application/json\");\n\n      // Récupérer le corps de la réponse\n      let data;\n      if (isJson) {\n        data = await response.json();\n        console.log(\"Données JSON reçues:\", data);\n      } else {\n        const text = await response.text();\n        console.warn(\"Réponse non-JSON reçue:\", text);\n        try {\n          // Essayer de parser le texte comme JSON\n          data = JSON.parse(text);\n          console.log(\"Texte parsé comme JSON:\", data);\n        } catch (e) {\n          data = { message: text };\n        }\n      }\n\n      // Gérer les différents codes de statut\n      if (response.ok) {\n        return data;\n      } else {\n        // Gérer les erreurs d'authentification (401, 403)\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", data);\n\n          // Afficher un message d'erreur mais ne pas rediriger\n          toast.error(\n            \"Session expirée ou accès non autorisé. Veuillez vous reconnecter.\"\n          );\n\n          // Ne pas supprimer le token et l'utilisateur du localStorage\n          // Ne pas rediriger vers la page de connexion\n\n          // Lancer une erreur avec un message clair\n          const error = new Error(\n            \"Veuillez vous connecter pour accéder à cette page.\"\n          );\n          error.status = response.status;\n          error.response = { status: response.status, data };\n          throw error;\n        }\n\n        // Gérer les erreurs serveur (500)\n        if (response.status === 500) {\n          console.error(\"Erreur serveur:\", data);\n          console.error(\"URL:\", response.url);\n          console.error(\"Méthode:\", response.method);\n\n          // Journaliser plus de détails pour le débogage\n          if (data.error) {\n            console.error(\"Détails de l'erreur:\", data.error);\n          }\n          if (data.stack) {\n            console.error(\"Stack trace:\", data.stack);\n          }\n        }\n\n        // Construire un message d'erreur détaillé\n        const errorMessage =\n          data.message ||\n          data.error ||\n          response.statusText ||\n          \"Erreur inconnue\";\n        const error = new Error(errorMessage);\n        error.status = response.status;\n        error.response = { status: response.status, data };\n\n        throw error;\n      }\n    } catch (error) {\n      console.error(\"Erreur lors du traitement de la réponse:\", error);\n      throw error;\n    }\n  }, []);\n\n  const api = useMemo(() => {\n    const get = async (endpoint) => {\n      try {\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5001\"; // Utiliser l'URL correcte\n        console.log(`[API] GET ${apiUrl}${endpoint}`);\n\n        const token = localStorage.getItem(\"token\");\n        const headers = {\n          \"Content-Type\": \"application/json\",\n          ...(token && { Authorization: `Bearer ${token}` }),\n        };\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"GET\",\n          headers,\n        });\n\n        return handleResponse(response);\n      } catch (error) {\n        console.error(`[API] GET ${endpoint} Error:`, error);\n        throw error;\n      }\n    };\n\n    // Fonction utilitaire pour convertir camelCase en snake_case\n    const camelToSnakeCase = (str) => {\n      // Cas spécial pour zipCode qui doit devenir zip_code\n      if (str === \"zipCode\") {\n        console.log(`Conversion spéciale: ${str} -> zip_code`);\n        return \"zip_code\";\n      }\n\n      // Conversion normale\n      const result = str.replace(\n        /[A-Z]/g,\n        (letter) => `_${letter.toLowerCase()}`\n      );\n      console.log(`Conversion camelCase -> snake_case: ${str} -> ${result}`);\n      return result;\n    };\n\n    const post = async (endpoint, data) => {\n      try {\n        // Vérifier que les données sont valides\n        if (!data || typeof data !== \"object\") {\n          console.error(\"Données invalides pour la requête POST:\", data);\n          throw new Error(\"Données invalides pour la requête POST\");\n        }\n\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5001\"; // Utiliser l'URL correcte\n        console.log(`[API] POST ${apiUrl}${endpoint}`);\n\n        // Vérifier si le token est présent\n        const token = localStorage.getItem(\"token\");\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        // S'assurer que les données sont sérialisables\n        const cleanData = JSON.parse(JSON.stringify(data));\n\n        // Supprimer hourlyRate des données pour éviter l'erreur\n        if (cleanData.hourlyRate !== undefined) {\n          console.log(\"Suppression de hourlyRate des données\");\n          delete cleanData.hourlyRate;\n        }\n\n        // Convertir les données en snake_case pour le backend\n        const snakeCaseData = {};\n        for (const key in cleanData) {\n          snakeCaseData[camelToSnakeCase(key)] = cleanData[key];\n        }\n        console.log(\n          \"Données converties en snake_case pour POST:\",\n          snakeCaseData\n        );\n\n        // Configurer les en-têtes de la requête\n        const headers = {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        };\n\n        // Journaliser les détails de la requête (sans le token complet)\n        console.log(\"Détails de la requête POST:\", {\n          endpoint,\n          dataSize: JSON.stringify(snakeCaseData).length,\n          headers: { ...headers, Authorization: \"Bearer [MASQUÉ]\" },\n        });\n\n        // Effectuer la requête avec un timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondes de timeout\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(snakeCaseData),\n          signal: controller.signal,\n        });\n\n        // Annuler le timeout\n        clearTimeout(timeoutId);\n\n        // Vérifier si la réponse est une erreur d'authentification\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", response.status);\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        // Traiter la réponse\n        return handleResponse(response);\n      } catch (error) {\n        // Gérer les erreurs spécifiques\n        if (error.name === \"AbortError\") {\n          console.error(\"La requête a été interrompue (timeout):\", error);\n          throw new Error(\n            \"La requête a pris trop de temps. Veuillez réessayer.\"\n          );\n        }\n\n        if (\n          error.message.includes(\"NetworkError\") ||\n          error.message.includes(\"Failed to fetch\")\n        ) {\n          console.error(\"Erreur réseau lors de la requête POST:\", error);\n          throw new Error(\n            \"Problème de connexion au serveur, veuillez vérifier votre connexion internet\"\n          );\n        }\n\n        // Journaliser et propager l'erreur\n        console.error(\"Erreur lors de la requête POST:\", error);\n        throw error;\n      }\n    };\n\n    const put = async (endpoint, data) => {\n      try {\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5001\"; // Utiliser l'URL correcte\n        console.log(`[API] PUT ${apiUrl}${endpoint}`, data);\n\n        const token = localStorage.getItem(\"token\");\n\n        // Vérifier si le token est présent\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        // S'assurer que les données sont sérialisables\n        const cleanData = JSON.parse(JSON.stringify(data));\n        console.log(\"Données nettoyées:\", cleanData);\n\n        // Supprimer hourlyRate des données pour éviter l'erreur\n        if (cleanData.hourlyRate !== undefined) {\n          console.log(\"Suppression de hourlyRate des données\");\n          delete cleanData.hourlyRate;\n        }\n\n        // Convertir les données en snake_case pour le backend\n        const snakeCaseData = {};\n        for (const key in cleanData) {\n          snakeCaseData[camelToSnakeCase(key)] = cleanData[key];\n        }\n        console.log(\"Données converties en snake_case:\", snakeCaseData);\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"PUT\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n          body: JSON.stringify(snakeCaseData),\n        });\n\n        // Vérifier si la réponse est une erreur d'authentification\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", response.status);\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        const result = await handleResponse(response);\n        console.log(`[API] PUT ${endpoint} Response:`, result);\n        return result;\n      } catch (error) {\n        console.error(`[API] PUT ${endpoint} Error:`, error);\n\n        // Ne pas rediriger automatiquement vers la page de connexion\n        // Laisser le composant gérer l'erreur\n\n        return {\n          ok: false,\n          status: error.status || 0,\n          data: { message: error.message || \"Erreur lors de la requête PUT\" },\n          headers: new Headers(),\n        };\n      }\n    };\n\n    const del = async (endpoint) => {\n      try {\n        // Vérifier que l'URL est correcte\n        const apiUrl = API_URL || \"http://localhost:5004\"; // Forcer l'URL correcte\n        console.log(`[API] DELETE ${apiUrl}${endpoint}`);\n\n        const token = localStorage.getItem(\"token\");\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        const response = await fetch(`${apiUrl}${endpoint}`, {\n          method: \"DELETE\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n        });\n\n        // Vérifier si la réponse est une erreur d'authentification\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", response.status);\n          throw new Error(\"Veuillez vous connecter pour accéder à cette page.\");\n        }\n\n        const result = await handleResponse(response);\n        console.log(`[API] DELETE ${endpoint} Response:`, result);\n        return result;\n      } catch (error) {\n        console.error(`[API] DELETE ${endpoint} Error:`, error);\n        return {\n          ok: false,\n          status: error.status || 0,\n          data: {\n            message: error.message || \"Erreur lors de la requête DELETE\",\n          },\n          headers: new Headers(),\n        };\n      }\n    };\n\n    return {\n      get,\n      post,\n      put,\n      delete: del,\n    };\n  }, [handleResponse]);\n\n  return api;\n};\n\nexport default useApi;\n"],"names":["useEmployees","employees","setEmployees","useState","loading","setLoading","error","setError","api","useApi","fetchEmployees","useCallback","async","apiUrl","API_URL","console","log","token","localStorage","getItem","Error","response","fetch","method","headers","Authorization","ok","errorData","json","message","data","Array","isArray","fetchEmployeeById","id","createEmployee","hourlyRate","cleanedData","employeeData","jsonData","JSON","parse","stringify","snakeCaseData","key","replace","letter","toLowerCase","body","prevEmployees","employee","success","updateEmployee","map","emp","deleteEmployee","filter","getEmployeesByStatus","status","fetchEmployeeHourBalance","randomDelay","Math","floor","random","Promise","resolve","setTimeout","get","undefined","hour_balance","balance","warn","prev","err","fetchAllEmployeesHourBalances","window","_isFetchingHourBalances","useEffect","mounted","retryCount","loadEmployees","API_ENDPOINTS","EMPLOYEES","BASE","pow","hourBalancesLoaded","useRef","length","current","timer","clearTimeout","handleResponse","forEach","value","url","statusText","contentType","includes","text","e","toast","stack","errorMessage","useMemo","camelToSnakeCase","str","result","endpoint","post","cleanData","dataSize","controller","AbortController","timeoutId","abort","signal","name","put","Headers","delete"],"sourceRoot":""}