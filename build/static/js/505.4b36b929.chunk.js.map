{"version":3,"file":"static/js/505.4b36b929.chunk.js","mappings":"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","sources":["utils/dateUtils.js","config/constants.js","services/api.js"],"sourcesContent":["/**\n * Utilitaires pour la gestion des dates dans l'application\n */\n\nimport {\n  addDays,\n  addWeeks as addWeeksDate,\n  endOfWeek,\n  format,\n  getDay,\n  isAfter,\n  isBefore,\n  isSameDay,\n  startOfWeek,\n} from \"date-fns\";\nimport { fr } from \"date-fns/locale\";\nimport { FRENCH_HOLIDAYS_2024 } from \"../config/constants\";\n\n/**\n * Formate une date selon le format spécifié\n * @param {Date} date - La date à formater\n * @param {string} formatStr - Le format à utiliser (par défaut: 'dd/MM/yyyy')\n * @returns {string} La date formatée\n */\nexport const formatDate = (date, formatStr = \"dd/MM/yyyy\") => {\n  if (!date) return \"\";\n\n  try {\n    // S'assurer que date est un objet Date valide\n    const dateObj = date instanceof Date ? date : new Date(date);\n\n    // Vérifier si la date est valide\n    if (isNaN(dateObj.getTime())) {\n      console.error(\"Date invalide dans formatDate:\", date);\n      return \"\";\n    }\n\n    return format(dateObj, formatStr, { locale: fr });\n  } catch (error) {\n    console.error(\"Erreur lors du formatage de la date:\", error, date);\n    return \"\";\n  }\n};\n\n/**\n * Formate une date pour un input HTML (YYYY-MM-DD)\n * @param {Date} date - La date à formater\n * @returns {string} La date au format YYYY-MM-DD\n */\nexport const formatDateForInput = (date) => {\n  if (!date) return \"\";\n  return format(date, \"yyyy-MM-dd\");\n};\n\n/**\n * Obtient le premier jour de la semaine pour une date donnée\n * @param {Date} date - La date de référence\n * @returns {Date} Le premier jour de la semaine (lundi)\n */\nexport const getWeekStart = (date) => {\n  return startOfWeek(date, { weekStartsOn: 1 });\n};\n\n/**\n * Obtient le dernier jour de la semaine pour une date donnée\n * @param {Date} date - La date de référence\n * @returns {Date} Le dernier jour de la semaine (dimanche)\n */\nexport const getWeekEnd = (date) => {\n  return endOfWeek(date, { weekStartsOn: 1 });\n};\n\n/**\n * Ajoute ou soustrait un nombre de semaines à une date\n * @param {Date} date - La date de référence\n * @param {number} amount - Le nombre de semaines à ajouter (négatif pour soustraire)\n * @returns {Date} La nouvelle date\n */\nexport const addWeeks = (date, amount) => {\n  return addWeeksDate(date, amount);\n};\n\n/**\n * Obtient un tableau des jours de la semaine pour une date donnée\n * @param {Date} date - La date de référence\n * @returns {Date[]} Un tableau des 7 jours de la semaine\n */\nexport const getDaysOfWeek = (date) => {\n  const weekStart = getWeekStart(date);\n  const days = [];\n\n  for (let i = 0; i < 7; i++) {\n    days.push(addDays(weekStart, i));\n  }\n\n  return days;\n};\n\n/**\n * Vérifie si une date est un weekend (samedi ou dimanche)\n * @param {Date} date - La date à vérifier\n * @returns {boolean} True si c'est un weekend\n */\nexport const isWeekend = (date) => {\n  const day = new Date(date).getDay();\n  return day === 0 || day === 6; // 0 = dimanche, 6 = samedi\n};\n\n/**\n * Calcule le nombre d'heures entre deux dates\n * @param {Date} startDate - Date de début\n * @param {Date} endDate - Date de fin\n * @returns {number} Nombre d'heures\n */\nexport const calculateHours = (startDate, endDate) => {\n  if (!startDate || !endDate) return 0;\n\n  const diffMs = endDate.getTime() - startDate.getTime();\n  const diffHours = diffMs / (1000 * 60 * 60);\n\n  return Math.round(diffHours * 10) / 10; // Arrondi à 1 décimale\n};\n\n/**\n * Formate une durée en heures et minutes\n * @param {number} hours - Nombre d'heures (peut inclure des décimales)\n * @returns {string} Durée formatée (ex: \"7h30\")\n */\nexport const formatHours = (hours) => {\n  if (hours === undefined || hours === null) return \"0h\";\n\n  const totalHours = parseFloat(hours);\n  if (isNaN(totalHours)) return \"0h\";\n\n  const wholeHours = Math.floor(totalHours);\n  const minutes = Math.round((totalHours - wholeHours) * 60);\n\n  if (minutes === 0) {\n    return `${wholeHours}h`;\n  } else {\n    return `${wholeHours}h${minutes.toString().padStart(2, \"0\")}`;\n  }\n};\n\n/**\n * Obtient le nom du jour de la semaine\n * @param {Date} date - La date\n * @param {boolean} short - Si true, retourne le nom court (3 lettres)\n * @returns {string} Le nom du jour\n */\nexport const getDayName = (date, short = false) => {\n  const days = [\n    \"Dimanche\",\n    \"Lundi\",\n    \"Mardi\",\n    \"Mercredi\",\n    \"Jeudi\",\n    \"Vendredi\",\n    \"Samedi\",\n  ];\n  const shortDays = [\"Dim\", \"Lun\", \"Mar\", \"Mer\", \"Jeu\", \"Ven\", \"Sam\"];\n\n  const dayIndex = new Date(date).getDay();\n  return short ? shortDays[dayIndex] : days[dayIndex];\n};\n\n/**\n * Obtient le nom du mois\n * @param {string|Date} date - La date\n * @param {boolean} short - Indique si le nom doit être court (3 lettres) ou complet\n * @returns {string} Le nom du mois\n */\nexport const getMonthName = (date, short = false) => {\n  const dateObj = new Date(date);\n  const monthNames = short\n    ? [\n        \"Jan\",\n        \"Fév\",\n        \"Mar\",\n        \"Avr\",\n        \"Mai\",\n        \"Juin\",\n        \"Juil\",\n        \"Aoû\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Déc\",\n      ]\n    : [\n        \"Janvier\",\n        \"Février\",\n        \"Mars\",\n        \"Avril\",\n        \"Mai\",\n        \"Juin\",\n        \"Juillet\",\n        \"Août\",\n        \"Septembre\",\n        \"Octobre\",\n        \"Novembre\",\n        \"Décembre\",\n      ];\n\n  return monthNames[dateObj.getMonth()];\n};\n\n/**\n * Formate une date pour MySQL (YYYY-MM-DD)\n * @param {string|Date} date - La date à formater\n * @returns {string} La date au format YYYY-MM-DD\n */\nexport const formatDateForMySQL = (date) => {\n  if (!date) return null;\n\n  // Si la date est déjà au format YYYY-MM-DD, la retourner telle quelle\n  if (typeof date === \"string\" && /^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\n    return date;\n  }\n\n  try {\n    const dateObj = new Date(date);\n\n    if (isNaN(dateObj.getTime())) {\n      return null;\n    }\n\n    return dateObj.toISOString().split(\"T\")[0];\n  } catch (error) {\n    console.error(\"Erreur lors du formatage de la date pour MySQL:\", error);\n    return null;\n  }\n};\n\n/**\n * Formate une date pour l'API (format YYYY-MM-DD)\n * @param {Date} date - La date à formater\n * @returns {string} La date formatée\n */\nexport const formatDateForAPI = (date) => {\n  if (!date) return \"\";\n  const d = new Date(date);\n  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(\n    2,\n    \"0\"\n  )}-${String(d.getDate()).padStart(2, \"0\")}`;\n};\n\n/**\n * Vérifie si une date est un jour férié\n * @param {string|Date} date - La date à vérifier\n * @param {Array} holidays - Liste des jours fériés (par défaut: jours fériés français 2024)\n * @returns {boolean} True si c'est un jour férié, false sinon\n */\nexport const isHoliday = (date, holidays = FRENCH_HOLIDAYS_2024) => {\n  if (!date) return false;\n\n  const d = new Date(date);\n  if (isNaN(d.getTime())) return false;\n\n  const formattedDate = formatDateForAPI(d);\n  return holidays.some((holiday) => holiday.date === formattedDate);\n};\n\n/**\n * Vérifie si une date est un jour ouvré (ni week-end, ni jour férié)\n * @param {string|Date} date - La date à vérifier\n * @param {Array} holidays - Liste des jours fériés\n * @returns {boolean} True si c'est un jour ouvré, false sinon\n */\nexport const isWorkingDay = (date, holidays = FRENCH_HOLIDAYS_2024) => {\n  return !isWeekend(date) && !isHoliday(date, holidays);\n};\n\n/**\n * Calcule le nombre de jours ouvrés entre deux dates\n * @param {string|Date} startDate - Date de début\n * @param {string|Date} endDate - Date de fin\n * @param {Array} holidays - Liste des jours fériés\n * @returns {number} Nombre de jours ouvrés\n */\nexport const getWorkingDaysCount = (\n  startDate,\n  endDate,\n  holidays = FRENCH_HOLIDAYS_2024\n) => {\n  if (!startDate || !endDate) return 0;\n\n  const start = new Date(startDate);\n  const end = new Date(endDate);\n\n  if (isNaN(start.getTime()) || isNaN(end.getTime())) return 0;\n  if (end < start) return 0;\n\n  let count = 0;\n  const currentDate = new Date(start);\n\n  while (currentDate <= end) {\n    if (isWorkingDay(currentDate, holidays)) {\n      count++;\n    }\n    currentDate.setDate(currentDate.getDate() + 1);\n  }\n\n  return count;\n};\n\n/**\n * Vérifie si une date est aujourd'hui\n * @param {string|Date} date - La date à vérifier\n * @returns {boolean} True si c'est aujourd'hui, false sinon\n */\nexport const isToday = (date) => {\n  if (!date) return false;\n  return isSameDay(new Date(date), new Date());\n};\n\n/**\n * Vérifie si une date est entre deux autres dates (inclusivement)\n * @param {string|Date} date - La date à vérifier\n * @param {string|Date} start - Date de début\n * @param {string|Date} end - Date de fin\n * @returns {boolean} True si la date est entre start et end, false sinon\n */\nexport const isDateBetween = (date, start, end) => {\n  if (!date || !start || !end) return false;\n\n  const d = new Date(date);\n  const s = new Date(start);\n  const e = new Date(end);\n\n  // Réinitialiser les heures pour comparer uniquement les dates\n  d.setHours(0, 0, 0, 0);\n  s.setHours(0, 0, 0, 0);\n  e.setHours(0, 0, 0, 0);\n\n  return d >= s && d <= e;\n};\n\n/**\n * Formate une date pour l'affichage en format français\n * @param {string|Date} date - La date à formater\n * @param {string} formatStr - Le format à utiliser (par défaut: 'dd/MM/yyyy')\n * @returns {string} La date formatée\n */\nexport const formatDateForDisplay = (date, formatStr = \"dd/MM/yyyy\") => {\n  if (!date) return \"\";\n\n  try {\n    // Si la date est déjà au format YYYY-MM-DD, la convertir en objet Date\n    const dateObj = typeof date === \"string\" ? new Date(date) : date;\n\n    // Formater la date selon le format spécifié\n    const day = String(dateObj.getDate()).padStart(2, \"0\");\n    const month = String(dateObj.getMonth() + 1).padStart(2, \"0\");\n    const year = dateObj.getFullYear();\n\n    return `${day}/${month}/${year}`;\n  } catch (error) {\n    console.error(\"Erreur lors du formatage de la date:\", error);\n    return \"\";\n  }\n};\n\n/**\n * Vérifie si une date est dans le passé\n * @param {Date} date - La date à vérifier\n * @returns {boolean} Vrai si la date est dans le passé\n */\nexport const isPast = (date) => {\n  return isBefore(date, new Date()) && !isToday(date);\n};\n\n/**\n * Vérifie si une date est dans le futur\n * @param {Date} date - La date à vérifier\n * @returns {boolean} Vrai si la date est dans le futur\n */\nexport const isFuture = (date) => {\n  return isAfter(date, new Date());\n};\n\n/**\n * Génère un tableau des jours de la semaine à partir d'une date de début\n * @param {Date} startDate - La date de début de la semaine\n * @returns {Array} Un tableau des jours de la semaine\n */\nexport const getWeekDays = (startDate) => {\n  const days = [];\n  for (let i = 0; i < 7; i++) {\n    days.push(addDays(startDate, i));\n  }\n  return days;\n};\n\n/**\n * Formate une date pour l'affichage dans un format court\n * @param {Date} date - La date à formater\n * @returns {string} La date formatée\n */\nexport const formatShortDate = (date) => {\n  return format(date, \"EEE dd/MM\", { locale: fr });\n};\n\n/**\n * Formate une date pour l'affichage dans un format long\n * @param {Date} date - La date à formater\n * @returns {string} La date formatée\n */\nexport const formatLongDate = (date) => {\n  return format(date, \"EEEE dd MMMM yyyy\", { locale: fr });\n};\n\n/**\n * Obtient le jour de la semaine (0-6, où 0 est dimanche)\n * @param {Date} date - La date\n * @returns {number} Le jour de la semaine\n */\nexport const getDayOfWeek = (date) => {\n  return getDay(date);\n};\n\n/**\n * Formate une heure pour l'affichage\n * @param {number} hours - Les heures\n * @param {number} minutes - Les minutes\n * @returns {string} L'heure formatée\n */\nexport const formatTime = (hours, minutes = 0) => {\n  return `${hours.toString().padStart(2, \"0\")}:${minutes\n    .toString()\n    .padStart(2, \"0\")}`;\n};\n\n/**\n * Convertit une chaîne de caractères au format \"HH:MM\" en minutes\n * @param {string} timeString - La chaîne de caractères au format \"HH:MM\"\n * @returns {number} Le nombre de minutes\n */\nexport const timeStringToMinutes = (timeString) => {\n  if (!timeString) return 0;\n\n  const [hours, minutes] = timeString.split(\":\").map(Number);\n  return hours * 60 + minutes;\n};\n\n/**\n * Convertit des minutes en chaîne de caractères au format \"HH:MM\"\n * @param {number} minutes - Le nombre de minutes\n * @returns {string} La chaîne de caractères au format \"HH:MM\"\n */\nexport const minutesToTimeString = (minutes) => {\n  if (!minutes && minutes !== 0) return \"\";\n\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n  return `${hours.toString().padStart(2, \"0\")}:${mins\n    .toString()\n    .padStart(2, \"0\")}`;\n};\n\n/**\n * Vérifie si une date est dans une plage de dates\n * @param {Date} date - La date à vérifier\n * @param {Date} start - La date de début de la plage\n * @param {Date} end - La date de fin de la plage\n * @returns {boolean} Vrai si la date est dans la plage\n */\nexport const isDateInRange = (date, start, end) => {\n  const d = new Date(date);\n  const s = new Date(start);\n  const e = new Date(end);\n  return d >= s && d <= e;\n};\n\nexport default {\n  addWeeks,\n  getWeekStart,\n  isToday,\n  isPast,\n  isFuture,\n  getWeekDays,\n  formatShortDate,\n  formatLongDate,\n  getDayOfWeek,\n  formatTime,\n  timeStringToMinutes,\n  minutesToTimeString,\n  formatDateForDisplay,\n  isDateInRange,\n};\n","// Constantes pour les employés\nexport const EMPLOYEE_DEPARTMENTS = [\n  { value: \"Marketing\", label: \"Marketing\" },\n  { value: \"Développement\", label: \"Développement\" },\n  { value: \"Design\", label: \"Design\" },\n  { value: \"Finance\", label: \"Finance\" },\n  { value: \"RH\", label: \"RH\" },\n];\n\nexport const EMPLOYEE_ROLES = [\n  { value: \"Manager\", label: \"Manager\" },\n  { value: \"Senior\", label: \"Senior\" },\n  { value: \"Junior\", label: \"Junior\" },\n  { value: \"Stagiaire\", label: \"Stagiaire\" },\n];\n\nexport const EMPLOYEE_STATUSES = [\n  { value: \"active\", label: \"Actif\" },\n  { value: \"pending\", label: \"En attente\" },\n  { value: \"inactive\", label: \"Inactif\" },\n];\n\n// Constantes pour les congés\nexport const VACATION_TYPES = [\n  { value: \"paid\", label: \"Congés payés\", color: \"#4CAF50\", defaultQuota: 25 },\n  { value: \"rtt\", label: \"RTT\", color: \"#2196F3\", defaultQuota: 11 },\n  {\n    value: \"unpaid\",\n    label: \"Congés sans solde\",\n    color: \"#9E9E9E\",\n    defaultQuota: null,\n  },\n  { value: \"sick\", label: \"Maladie\", color: \"#F44336\", defaultQuota: null },\n  {\n    value: \"exceptional\",\n    label: \"Absence exceptionnelle\",\n    color: \"#FF9800\",\n    defaultQuota: null,\n  },\n  {\n    value: \"recovery\",\n    label: \"Récupération\",\n    color: \"#9C27B0\",\n    defaultQuota: null,\n  },\n];\n\nexport const VACATION_STATUSES = [\n  { value: \"pending\", label: \"En attente\", color: \"#FFC107\" },\n  { value: \"approved\", label: \"Approuvé\", color: \"#4CAF50\" },\n  { value: \"rejected\", label: \"Refusé\", color: \"#F44336\" },\n];\n\n// Jours fériés en France pour 2024 (à mettre à jour chaque année)\nexport const FRENCH_HOLIDAYS_2024 = [\n  { date: \"2024-01-01\", name: \"Jour de l'an\" },\n  { date: \"2024-04-01\", name: \"Lundi de Pâques\" },\n  { date: \"2024-05-01\", name: \"Fête du Travail\" },\n  { date: \"2024-05-08\", name: \"Victoire 1945\" },\n  { date: \"2024-05-09\", name: \"Ascension\" },\n  { date: \"2024-05-20\", name: \"Lundi de Pentecôte\" },\n  { date: \"2024-07-14\", name: \"Fête Nationale\" },\n  { date: \"2024-08-15\", name: \"Assomption\" },\n  { date: \"2024-11-01\", name: \"Toussaint\" },\n  { date: \"2024-11-11\", name: \"Armistice 1918\" },\n  { date: \"2024-12-25\", name: \"Noël\" },\n];\n\n// Constantes pour les colonnes du tableau des employés\nexport const EMPLOYEE_TABLE_COLUMNS = [\n  {\n    id: \"name\",\n    header: \"Nom\",\n    accessor: (employee) => `${employee.first_name} ${employee.last_name}`,\n    sortable: true,\n  },\n  {\n    id: \"email\",\n    header: \"Email\",\n    accessor: (employee) => employee.email,\n    sortable: true,\n  },\n  {\n    id: \"department\",\n    header: \"Département\",\n    accessor: (employee) => employee.department,\n    sortable: true,\n  },\n  {\n    id: \"role\",\n    header: \"Rôle\",\n    accessor: (employee) => employee.role,\n    sortable: true,\n  },\n  {\n    id: \"status\",\n    header: \"Statut\",\n    accessor: (employee) => employee.status,\n    sortable: true,\n    type: \"status\",\n  },\n  {\n    id: \"hour_balance\",\n    header: \"Solde d'heures\",\n    accessor: (employee) => {\n      const balance = employee.hour_balance || 0;\n      const isPositive = balance >= 0;\n      return {\n        value: balance,\n        display: `${isPositive ? \"+\" : \"\"}${balance}h`,\n        isPositive,\n      };\n    },\n    sortable: true,\n    type: \"hour_balance\",\n  },\n  {\n    id: \"hire_date\",\n    header: \"Date d'embauche\",\n    accessor: (employee) => {\n      if (!employee.hire_date) return \"\";\n      const date = new Date(employee.hire_date);\n      return date.toLocaleDateString(\"fr-FR\");\n    },\n    sortable: true,\n    type: \"date\",\n  },\n];\n\n// URL de l'API\nexport const API_URL =\n  process.env.REACT_APP_API_URL || \"http://localhost:5001/api\";\n","import { API_ENDPOINTS, apiRequest } from \"../config/api\";\nimport { formatDateForAPI } from \"../utils/dateUtils\";\n\nexport const AuthService = {\n  login: async (email, password) => {\n    console.log(\"🔐 Tentative de connexion avec:\", { email, password: \"***\" });\n    try {\n      const response = await apiRequest(API_ENDPOINTS.LOGIN, \"POST\", {\n        email,\n        password,\n      });\n\n      if (response.error) {\n        console.error(\"❌ Erreur de connexion:\", response.error);\n        return { success: false, message: response.error };\n      }\n\n      if (response.token) {\n        console.log(\"✅ Connexion réussie, token reçu\");\n        localStorage.setItem(\"token\", response.token);\n        localStorage.setItem(\n          \"user\",\n          JSON.stringify({\n            id: response.id,\n            email: response.email,\n            role: response.role,\n            first_name: response.first_name,\n            last_name: response.last_name,\n          })\n        );\n        return { success: true, user: response };\n      } else {\n        console.error(\"❌ Connexion échouée: pas de token reçu\");\n        return { success: false, message: \"Erreur d'authentification\" };\n      }\n    } catch (error) {\n      console.error(\"❌ Erreur lors de la connexion:\", error);\n      return {\n        success: false,\n        message: error.message || \"Erreur de connexion\",\n      };\n    }\n  },\n\n  register: async (userData) => {\n    try {\n      const response = await apiRequest(API_ENDPOINTS.REGISTER, \"POST\", {\n        ...userData,\n        first_name: userData.first_name,\n        last_name: userData.last_name,\n      });\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, user: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur d'inscription\",\n      };\n    }\n  },\n\n  logout: () => {\n    localStorage.removeItem(\"token\");\n    localStorage.removeItem(\"user\");\n    return { success: true };\n  },\n\n  getCurrentUser: () => {\n    const userStr = localStorage.getItem(\"user\");\n    if (!userStr) return null;\n\n    try {\n      return JSON.parse(userStr);\n    } catch (error) {\n      console.error(\"Erreur lors de la récupération de l'utilisateur:\", error);\n      return null;\n    }\n  },\n};\n\nexport const EmployeeService = {\n  getAll: async () => {\n    try {\n      const response = await apiRequest(API_ENDPOINTS.EMPLOYEES.BASE, \"GET\");\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, employees: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la récupération des employés\",\n      };\n    }\n  },\n\n  getById: async (id) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.EMPLOYEES.BY_ID(id),\n        \"GET\"\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return {\n        ...response,\n        first_name: response.first_name,\n        last_name: response.last_name,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la récupération de l'employé\",\n      };\n    }\n  },\n\n  create: async (employeeData) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.EMPLOYEES.BASE,\n        \"POST\",\n        employeeData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, employee: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la création de l'employé\",\n      };\n    }\n  },\n\n  update: async (id, employeeData) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.EMPLOYEES.BY_ID(id),\n        \"PUT\",\n        employeeData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, employee: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la mise à jour de l'employé\",\n      };\n    }\n  },\n\n  delete: async (id) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.EMPLOYEES.BY_ID(id),\n        \"DELETE\"\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la suppression de l'employé\",\n      };\n    }\n  },\n};\n\nexport const VacationService = {\n  getAll: async () => {\n    try {\n      const response = await apiRequest(API_ENDPOINTS.VACATIONS, \"GET\");\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, vacations: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la récupération des congés\",\n      };\n    }\n  },\n\n  getById: async (id) => {\n    try {\n      const response = await apiRequest(\n        `${API_ENDPOINTS.VACATIONS}/${id}`,\n        \"GET\"\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, vacation: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la récupération du congé\",\n      };\n    }\n  },\n\n  create: async (vacationData) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.VACATIONS,\n        \"POST\",\n        vacationData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, vacation: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la création du congé\",\n      };\n    }\n  },\n\n  update: async (id, vacationData) => {\n    try {\n      const response = await apiRequest(\n        `${API_ENDPOINTS.VACATIONS}/${id}`,\n        \"PUT\",\n        vacationData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, vacation: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la mise à jour du congé\",\n      };\n    }\n  },\n\n  delete: async (id) => {\n    try {\n      const response = await apiRequest(\n        `${API_ENDPOINTS.VACATIONS}/${id}`,\n        \"DELETE\"\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la suppression du congé\",\n      };\n    }\n  },\n};\n\nexport const ActivityService = {\n  getAll: async () => {\n    try {\n      const response = await apiRequest(API_ENDPOINTS.ACTIVITIES.LIST, \"GET\");\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, activities: response };\n    } catch (error) {\n      return {\n        success: false,\n        message:\n          error.message || \"Erreur lors de la récupération des activités\",\n      };\n    }\n  },\n\n  create: async (activityData) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.ACTIVITIES.CREATE,\n        \"POST\",\n        activityData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, activity: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la création de l'activité\",\n      };\n    }\n  },\n\n  update: async (id, activityData) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.ACTIVITIES.UPDATE(id),\n        \"PUT\",\n        activityData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, activity: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la mise à jour de l'activité\",\n      };\n    }\n  },\n\n  delete: async (id) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.ACTIVITIES.DELETE(id),\n        \"DELETE\"\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la suppression de l'activité\",\n      };\n    }\n  },\n};\n\nexport const WeeklyScheduleService = {\n  getAll: async () => {\n    try {\n      const response = await apiRequest(API_ENDPOINTS.WEEKLY_SCHEDULES, \"GET\");\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, schedules: response };\n    } catch (error) {\n      return {\n        success: false,\n        message:\n          error.message || \"Erreur lors de la récupération des plannings\",\n      };\n    }\n  },\n\n  getByWeek: async (weekStart) => {\n    try {\n      if (!weekStart) {\n        console.error(\"Date de début de semaine non spécifiée\");\n        return { success: false, message: \"Date de début de semaine requise\" };\n      }\n\n      // Vérifier que le token d'authentification est présent\n      const token = localStorage.getItem(\"token\");\n      console.error(\n        \"Token d'authentification:\",\n        token ? \"Présent\" : \"Manquant\",\n        token ? `(${token.substring(0, 10)}...)` : \"\"\n      );\n\n      if (!token) {\n        console.error(\"Token d'authentification manquant\");\n        return {\n          success: false,\n          message: \"Vous devez être connecté pour accéder à ces données\",\n        };\n      }\n\n      console.error(\n        \"Appel API pour récupérer les plannings de la semaine:\",\n        weekStart\n      );\n\n      try {\n        const response = await apiRequest(\n          `${API_ENDPOINTS.WEEKLY_SCHEDULES}/week/${weekStart}`,\n          \"GET\"\n        );\n\n        if (response.error) {\n          console.error(\n            \"Erreur API lors de la récupération des plannings:\",\n            response.error\n          );\n          return {\n            success: false,\n            message: response.error,\n            details: response.details || \"\",\n          };\n        }\n\n        console.error(\n          \"Réponse API pour les plannings:\",\n          JSON.stringify(response).substring(0, 200) + \"...\"\n        );\n\n        return { success: true, schedules: response };\n      } catch (apiError) {\n        console.error(\"Exception lors de l'appel API:\", apiError);\n        return {\n          success: false,\n          message:\n            apiError.message || \"Erreur lors de la récupération des plannings\",\n          details: apiError.details || \"\",\n        };\n      }\n    } catch (error) {\n      console.error(\"Exception lors de la récupération des plannings:\", error);\n      return {\n        success: false,\n        message:\n          error.message ||\n          \"Erreur lors de la récupération des plannings pour cette semaine\",\n        details: error.details || \"\",\n      };\n    }\n  },\n\n  getByEmployee: async (employeeId) => {\n    try {\n      const response = await apiRequest(\n        `${API_ENDPOINTS.EMPLOYEES.SCHEDULES(employeeId)}`,\n        \"GET\"\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, schedules: response };\n    } catch (error) {\n      return {\n        success: false,\n        message:\n          error.message ||\n          \"Erreur lors de la récupération des plannings de l'employé\",\n      };\n    }\n  },\n\n  getByEmployeeAndWeek: async (employeeId, weekStart) => {\n    try {\n      if (!employeeId) {\n        console.error(\"ID employé non spécifié\");\n        return { success: false, message: \"ID employé requis\" };\n      }\n\n      if (!weekStart) {\n        console.error(\"Date de début de semaine non spécifiée\");\n        return { success: false, message: \"Date de début de semaine requise\" };\n      }\n\n      // S'assurer que la date est au format YYYY-MM-DD\n      let formattedDate = weekStart;\n      if (weekStart instanceof Date) {\n        formattedDate = formatDateForAPI(weekStart);\n      } else if (typeof weekStart === \"string\" && weekStart.includes(\"T\")) {\n        // Si la date contient un T (format ISO), extraire seulement la partie date\n        formattedDate = weekStart.split(\"T\")[0];\n      }\n\n      console.error(\n        \"Appel API pour récupérer le planning de l'employé:\",\n        employeeId,\n        \"semaine du:\",\n        formattedDate\n      );\n\n      const response = await apiRequest(\n        `${API_ENDPOINTS.WEEKLY_SCHEDULES}/employee/${employeeId}/week/${formattedDate}`,\n        \"GET\"\n      );\n\n      if (response.error) {\n        console.error(\n          \"Erreur API lors de la récupération du planning:\",\n          response.error\n        );\n        return { success: false, message: response.error };\n      }\n\n      return response; // La réponse contient déjà success et schedule\n    } catch (error) {\n      console.error(\"Exception lors de la récupération du planning:\", error);\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la récupération du planning\",\n      };\n    }\n  },\n\n  create: async (scheduleData) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.WEEKLY_SCHEDULES,\n        \"POST\",\n        scheduleData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, schedule: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la création du planning\",\n      };\n    }\n  },\n\n  update: async (id, scheduleData) => {\n    try {\n      const response = await apiRequest(\n        `${API_ENDPOINTS.WEEKLY_SCHEDULES}/${id}`,\n        \"PUT\",\n        scheduleData\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true, schedule: response };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la mise à jour du planning\",\n      };\n    }\n  },\n\n  delete: async (id) => {\n    try {\n      const response = await apiRequest(\n        `${API_ENDPOINTS.WEEKLY_SCHEDULES}/${id}`,\n        \"DELETE\"\n      );\n\n      if (response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        message: error.message || \"Erreur lors de la suppression du planning\",\n      };\n    }\n  },\n};\n\nexport const HourBalanceService = {\n  getByEmployee: async (employeeId) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.HOUR_BALANCE.BY_EMPLOYEE(employeeId),\n        \"GET\"\n      );\n\n      if (response && response.error) {\n        return { success: false, message: response.error };\n      }\n\n      if (response && typeof response.balance !== \"undefined\") {\n        return { success: true, balance: response.balance };\n      }\n\n      if (response && typeof response === \"object\") {\n        if (typeof response.hour_balance !== \"undefined\") {\n          return { success: true, balance: response.hour_balance };\n        }\n\n        if (\n          Object.keys(response).length === 1 &&\n          typeof Object.values(response)[0] === \"number\"\n        ) {\n          return { success: true, balance: Object.values(response)[0] };\n        }\n      }\n\n      console.warn(\n        `Avertissement: Format de réponse inattendu pour le solde d'heures de l'employé ${employeeId}:`,\n        response\n      );\n      return { success: true, balance: 0 };\n    } catch (error) {\n      console.warn(\n        \"Avertissement lors de la récupération du solde d'heures:\",\n        error\n      );\n      return {\n        success: false,\n        message:\n          error.message || \"Erreur lors de la récupération du solde d'heures\",\n      };\n    }\n  },\n\n  updateBalance: async (employeeId, balanceData) => {\n    try {\n      const response = await apiRequest(\n        API_ENDPOINTS.HOUR_BALANCE.BY_EMPLOYEE(employeeId),\n        \"PUT\",\n        balanceData\n      );\n\n      if (response && response.error) {\n        return { success: false, message: response.error };\n      }\n\n      return {\n        success: true,\n        balance:\n          response.balance ||\n          response.hour_balance ||\n          (typeof response === \"number\" ? response : 0),\n      };\n    } catch (error) {\n      console.error(\"Erreur lors de la mise à jour du solde d'heures:\", error);\n      return {\n        success: false,\n        message:\n          error.message || \"Erreur lors de la mise à jour du solde d'heures\",\n      };\n    }\n  },\n};\n"],"names":["formatDate","date","formatStr","arguments","length","undefined","dateObj","Date","isNaN","getTime","console","error","format","locale","fr","formatDateForInput","getWeekStart","startOfWeek","weekStartsOn","getWeekEnd","endOfWeek","addWeeks","amount","addWeeksDate","getDaysOfWeek","weekStart","days","i","push","addDays","isWeekend","day","getDay","calculateHours","startDate","endDate","diffHours","Math","round","getDayName","short","dayIndex","formatDateForAPI","d","getFullYear","String","getMonth","padStart","getDate","isHoliday","holidays","FRENCH_HOLIDAYS_2024","formattedDate","some","holiday","isWorkingDay","getWorkingDaysCount","start","end","count","currentDate","setDate","formatDateForDisplay","month","EMPLOYEE_STATUSES","value","label","VACATION_TYPES","color","defaultQuota","name","EMPLOYEE_TABLE_COLUMNS","id","header","accessor","employee","first_name","last_name","sortable","email","department","role","status","type","balance","hour_balance","isPositive","display","hire_date","toLocaleDateString","AuthService","login","async","password","log","response","apiRequest","API_ENDPOINTS","LOGIN","success","message","token","localStorage","setItem","JSON","stringify","user","register","REGISTER","userData","logout","removeItem","getCurrentUser","userStr","getItem","parse","WeeklyScheduleService","getAll","WEEKLY_SCHEDULES","schedules","getByWeek","substring","details","apiError","getByEmployee","EMPLOYEES","SCHEDULES","employeeId","getByEmployeeAndWeek","includes","split","create","scheduleData","schedule","update","delete","HourBalanceService","HOUR_BALANCE","BY_EMPLOYEE","Object","keys","values","warn","updateBalance","balanceData"],"sourceRoot":""}