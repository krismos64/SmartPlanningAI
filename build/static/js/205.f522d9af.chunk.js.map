{"version":3,"file":"static/js/205.f522d9af.chunk.js","mappings":"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","sources":["utils/dateUtils.js","hooks/useEmployees.js","config/constants.js","hooks/useApi.js"],"sourcesContent":["/**\n * Utilitaires pour la gestion des dates dans l'application\n */\n\nimport {\n  addDays,\n  addWeeks as addWeeksDate,\n  endOfWeek,\n  format,\n  startOfWeek,\n} from \"date-fns\";\nimport { fr } from \"date-fns/locale\";\nimport { FRENCH_HOLIDAYS_2024 } from \"../config/constants\";\n\n/**\n * Formate une date selon le format spécifié\n * @param {Date} date - La date à formater\n * @param {string} formatStr - Le format à utiliser (par défaut: 'dd/MM/yyyy')\n * @returns {string} La date formatée\n */\nexport const formatDate = (date, formatStr = \"dd/MM/yyyy\") => {\n  if (!date) return \"\";\n\n  try {\n    // S'assurer que date est un objet Date valide\n    const dateObj = date instanceof Date ? date : new Date(date);\n\n    // Vérifier si la date est valide\n    if (isNaN(dateObj.getTime())) {\n      console.error(\"Date invalide dans formatDate:\", date);\n      return \"\";\n    }\n\n    return format(dateObj, formatStr, { locale: fr });\n  } catch (error) {\n    console.error(\"Erreur lors du formatage de la date:\", error, date);\n    return \"\";\n  }\n};\n\n/**\n * Formate une date pour un input HTML (YYYY-MM-DD)\n * @param {Date} date - La date à formater\n * @returns {string} La date au format YYYY-MM-DD\n */\nexport const formatDateForInput = (date) => {\n  if (!date) return \"\";\n  return format(date, \"yyyy-MM-dd\");\n};\n\n/**\n * Obtient le premier jour de la semaine pour une date donnée\n * @param {Date} date - La date de référence\n * @returns {Date} Le premier jour de la semaine (lundi)\n */\nexport const getWeekStart = (date) => {\n  return startOfWeek(date, { weekStartsOn: 1 });\n};\n\n/**\n * Obtient le dernier jour de la semaine pour une date donnée\n * @param {Date} date - La date de référence\n * @returns {Date} Le dernier jour de la semaine (dimanche)\n */\nexport const getWeekEnd = (date) => {\n  return endOfWeek(date, { weekStartsOn: 1 });\n};\n\n/**\n * Ajoute ou soustrait un nombre de semaines à une date\n * @param {Date} date - La date de référence\n * @param {number} amount - Le nombre de semaines à ajouter (négatif pour soustraire)\n * @returns {Date} La nouvelle date\n */\nexport const addWeeks = (date, amount) => {\n  return addWeeksDate(date, amount);\n};\n\n/**\n * Obtient un tableau des jours de la semaine pour une date donnée\n * @param {Date} date - La date de référence\n * @returns {Date[]} Un tableau des 7 jours de la semaine\n */\nexport const getDaysOfWeek = (date) => {\n  const weekStart = getWeekStart(date);\n  const days = [];\n\n  for (let i = 0; i < 7; i++) {\n    days.push(addDays(weekStart, i));\n  }\n\n  return days;\n};\n\n/**\n * Vérifie si une date est un weekend (samedi ou dimanche)\n * @param {Date} date - La date à vérifier\n * @returns {boolean} True si c'est un weekend\n */\nexport const isWeekend = (date) => {\n  const day = new Date(date).getDay();\n  return day === 0 || day === 6; // 0 = dimanche, 6 = samedi\n};\n\n/**\n * Calcule le nombre d'heures entre deux dates\n * @param {Date} startDate - Date de début\n * @param {Date} endDate - Date de fin\n * @returns {number} Nombre d'heures\n */\nexport const calculateHours = (startDate, endDate) => {\n  if (!startDate || !endDate) return 0;\n\n  const diffMs = endDate.getTime() - startDate.getTime();\n  const diffHours = diffMs / (1000 * 60 * 60);\n\n  return Math.round(diffHours * 10) / 10; // Arrondi à 1 décimale\n};\n\n/**\n * Formate une durée en heures et minutes\n * @param {number} hours - Nombre d'heures (peut inclure des décimales)\n * @returns {string} Durée formatée (ex: \"7h30\")\n */\nexport const formatHours = (hours) => {\n  if (hours === undefined || hours === null) return \"0h\";\n\n  const totalHours = parseFloat(hours);\n  if (isNaN(totalHours)) return \"0h\";\n\n  const wholeHours = Math.floor(totalHours);\n  const minutes = Math.round((totalHours - wholeHours) * 60);\n\n  if (minutes === 0) {\n    return `${wholeHours}h`;\n  } else {\n    return `${wholeHours}h${minutes.toString().padStart(2, \"0\")}`;\n  }\n};\n\n/**\n * Obtient le nom du jour de la semaine\n * @param {Date} date - La date\n * @param {boolean} short - Si true, retourne le nom court (3 lettres)\n * @returns {string} Le nom du jour\n */\nexport const getDayName = (date, short = false) => {\n  const days = [\n    \"Dimanche\",\n    \"Lundi\",\n    \"Mardi\",\n    \"Mercredi\",\n    \"Jeudi\",\n    \"Vendredi\",\n    \"Samedi\",\n  ];\n  const shortDays = [\"Dim\", \"Lun\", \"Mar\", \"Mer\", \"Jeu\", \"Ven\", \"Sam\"];\n\n  const dayIndex = new Date(date).getDay();\n  return short ? shortDays[dayIndex] : days[dayIndex];\n};\n\n/**\n * Obtient le nom du mois\n * @param {string|Date} date - La date\n * @param {boolean} short - Indique si le nom doit être court (3 lettres) ou complet\n * @returns {string} Le nom du mois\n */\nexport const getMonthName = (date, short = false) => {\n  const dateObj = new Date(date);\n  const monthNames = short\n    ? [\n        \"Jan\",\n        \"Fév\",\n        \"Mar\",\n        \"Avr\",\n        \"Mai\",\n        \"Juin\",\n        \"Juil\",\n        \"Aoû\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Déc\",\n      ]\n    : [\n        \"Janvier\",\n        \"Février\",\n        \"Mars\",\n        \"Avril\",\n        \"Mai\",\n        \"Juin\",\n        \"Juillet\",\n        \"Août\",\n        \"Septembre\",\n        \"Octobre\",\n        \"Novembre\",\n        \"Décembre\",\n      ];\n\n  return monthNames[dateObj.getMonth()];\n};\n\n/**\n * Formate une date pour MySQL (YYYY-MM-DD)\n * @param {string|Date} date - La date à formater\n * @returns {string} La date au format YYYY-MM-DD\n */\nexport const formatDateForMySQL = (date) => {\n  if (!date) return null;\n\n  // Si la date est déjà au format YYYY-MM-DD, la retourner telle quelle\n  if (typeof date === \"string\" && /^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\n    return date;\n  }\n\n  try {\n    const dateObj = new Date(date);\n\n    if (isNaN(dateObj.getTime())) {\n      return null;\n    }\n\n    return dateObj.toISOString().split(\"T\")[0];\n  } catch (error) {\n    console.error(\"Erreur lors du formatage de la date pour MySQL:\", error);\n    return null;\n  }\n};\n\n/**\n * Formate une date pour l'API (format YYYY-MM-DD)\n * @param {Date} date - La date à formater\n * @returns {string} La date formatée\n */\nexport const formatDateForAPI = (date) => {\n  if (!date) return \"\";\n  const d = new Date(date);\n  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(\n    2,\n    \"0\"\n  )}-${String(d.getDate()).padStart(2, \"0\")}`;\n};\n\n/**\n * Vérifie si une date est un jour férié\n * @param {string|Date} date - La date à vérifier\n * @param {Array} holidays - Liste des jours fériés (par défaut: jours fériés français 2024)\n * @returns {boolean} True si c'est un jour férié, false sinon\n */\nexport const isHoliday = (date, holidays = FRENCH_HOLIDAYS_2024) => {\n  if (!date) return false;\n\n  const d = new Date(date);\n  if (isNaN(d.getTime())) return false;\n\n  const formattedDate = formatDateForAPI(d);\n  return holidays.some((holiday) => holiday.date === formattedDate);\n};\n\n/**\n * Vérifie si une date est un jour ouvré (ni week-end, ni jour férié)\n * @param {string|Date} date - La date à vérifier\n * @param {Array} holidays - Liste des jours fériés\n * @returns {boolean} True si c'est un jour ouvré, false sinon\n */\nexport const isWorkingDay = (date, holidays = FRENCH_HOLIDAYS_2024) => {\n  return !isWeekend(date) && !isHoliday(date, holidays);\n};\n\n/**\n * Calcule le nombre de jours ouvrés entre deux dates\n * @param {string|Date} startDate - Date de début\n * @param {string|Date} endDate - Date de fin\n * @param {Array} holidays - Liste des jours fériés\n * @returns {number} Nombre de jours ouvrés\n */\nexport const getWorkingDaysCount = (\n  startDate,\n  endDate,\n  holidays = FRENCH_HOLIDAYS_2024\n) => {\n  if (!startDate || !endDate) return 0;\n\n  const start = new Date(startDate);\n  const end = new Date(endDate);\n\n  if (isNaN(start.getTime()) || isNaN(end.getTime())) return 0;\n  if (end < start) return 0;\n\n  let count = 0;\n  const currentDate = new Date(start);\n\n  while (currentDate <= end) {\n    if (isWorkingDay(currentDate, holidays)) {\n      count++;\n    }\n    currentDate.setDate(currentDate.getDate() + 1);\n  }\n\n  return count;\n};\n\n/**\n * Vérifie si deux dates sont le même jour\n * @param {string|Date} date1 - Première date\n * @param {string|Date} date2 - Deuxième date\n * @returns {boolean} True si c'est le même jour, false sinon\n */\nexport const isSameDay = (date1, date2) => {\n  if (!date1 || !date2) return false;\n\n  const d1 = new Date(date1);\n  const d2 = new Date(date2);\n\n  return (\n    d1.getFullYear() === d2.getFullYear() &&\n    d1.getMonth() === d2.getMonth() &&\n    d1.getDate() === d2.getDate()\n  );\n};\n\n/**\n * Vérifie si une date est aujourd'hui\n * @param {string|Date} date - La date à vérifier\n * @returns {boolean} True si c'est aujourd'hui, false sinon\n */\nexport const isToday = (date) => {\n  return isSameDay(date, new Date());\n};\n\n/**\n * Vérifie si une date est entre deux autres dates (inclusivement)\n * @param {string|Date} date - La date à vérifier\n * @param {string|Date} start - Date de début\n * @param {string|Date} end - Date de fin\n * @returns {boolean} True si la date est entre start et end, false sinon\n */\nexport const isDateBetween = (date, start, end) => {\n  if (!date || !start || !end) return false;\n\n  const d = new Date(date);\n  const s = new Date(start);\n  const e = new Date(end);\n\n  // Réinitialiser les heures pour comparer uniquement les dates\n  d.setHours(0, 0, 0, 0);\n  s.setHours(0, 0, 0, 0);\n  e.setHours(0, 0, 0, 0);\n\n  return d >= s && d <= e;\n};\n","import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { API_ENDPOINTS } from \"../config/api\";\nimport useApi from \"./useApi\";\n\n/**\n * Hook personnalisé pour gérer les employés\n */\nconst useEmployees = () => {\n  const [employees, setEmployees] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const api = useApi();\n\n  /**\n   * Récupère tous les employés\n   */\n  const fetchEmployees = useCallback(async () => {\n    if (!loading) setLoading(true);\n    try {\n      const response = await api.get(API_ENDPOINTS.EMPLOYEES.BASE);\n\n      if (response.ok) {\n        // S'assurer que les données sont un tableau\n        const employeesData = Array.isArray(response.data) ? response.data : [];\n        setEmployees(employeesData);\n        setError(null);\n      } else {\n        throw new Error(\n          response.data?.message || \"Erreur lors du chargement des employés\"\n        );\n      }\n    } catch (err) {\n      console.error(\"Erreur lors du chargement des employés:\", err);\n      setError(\"Erreur lors du chargement des employés\");\n      toast.error(\"Erreur lors du chargement des employés\");\n      // En cas d'erreur, s'assurer que employees reste un tableau vide\n      setEmployees([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [api, loading]);\n\n  /**\n   * Récupère un employé par son ID\n   */\n  const fetchEmployeeById = useCallback(\n    async (id) => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const response = await api.get(API_ENDPOINTS.EMPLOYEES.BY_ID(id));\n\n        if (response.ok) {\n          return response.data;\n        } else {\n          throw new Error(\n            response.data?.message ||\n              \"Erreur lors de la récupération de l'employé\"\n          );\n        }\n      } catch (err) {\n        console.error(\n          `Erreur lors de la récupération de l'employé #${id}:`,\n          err\n        );\n        setError(err.message || \"Erreur lors de la récupération de l'employé\");\n        toast.error(\"Erreur lors de la récupération de l'employé\");\n        return null;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [api]\n  );\n\n  /**\n   * Crée un nouvel employé\n   */\n  const createEmployee = useCallback(\n    async (employeeData) => {\n      setLoading(true);\n      try {\n        const response = await api.post(\n          API_ENDPOINTS.EMPLOYEES.BASE,\n          employeeData\n        );\n\n        if (response && response.id) {\n          // Mettre à jour la liste des employés\n          setEmployees((prevEmployees) => [...prevEmployees, response]);\n          setError(null);\n          return response;\n        } else {\n          // Si la réponse est un objet mais ne contient pas d'employé, vérifier s'il y a un message d'erreur\n          if (response && typeof response === \"object\") {\n            if (response.message && response.message.includes(\"erreur\")) {\n              return { success: false, error: response.message };\n            }\n\n            // Si la réponse est l'employé lui-même\n            if (response.id) {\n              setEmployees((prev) => [...prev, response]);\n              return { success: true, employee: response };\n            }\n          }\n\n          // Fallback pour les anciennes API qui renvoient directement l'employé\n          setEmployees((prev) => [...prev, response]);\n          return { success: true, employee: response };\n        }\n      } catch (err) {\n        console.error(\"Erreur lors de la création de l'employé:\", err);\n\n        // Extraire un message d'erreur plus précis si possible\n        let errorMessage = \"Erreur lors de la création de l'employé\";\n\n        if (err.response && err.response.data) {\n          errorMessage = err.response.data.message || errorMessage;\n        } else if (err.message) {\n          errorMessage = err.message;\n        }\n\n        return { success: false, error: errorMessage };\n      } finally {\n        setLoading(false);\n      }\n    },\n    [api]\n  );\n\n  /**\n   * Met à jour un employé existant\n   */\n  const updateEmployee = useCallback(\n    async (id, employeeData) => {\n      setLoading(true);\n      try {\n        const response = await api.put(\n          `${API_ENDPOINTS.EMPLOYEES.BASE}/${id}`,\n          employeeData\n        );\n\n        if (response) {\n          // Mettre à jour la liste des employés\n          setEmployees((prevEmployees) =>\n            prevEmployees.map((emp) =>\n              emp.id === id ? { ...emp, ...response.data } : emp\n            )\n          );\n          setError(null);\n          return response.data;\n        }\n      } catch (err) {\n        console.error(\"Erreur lors de la mise à jour de l'employé:\", err);\n        return { success: false, error: err.message || \"Erreur inconnue\" };\n      } finally {\n        setLoading(false);\n      }\n    },\n    [api]\n  );\n\n  /**\n   * Supprime un employé\n   */\n  const deleteEmployee = useCallback(\n    async (id) => {\n      setLoading(true);\n      try {\n        const response = await api.delete(\n          `${API_ENDPOINTS.EMPLOYEES.BASE}/${id}`\n        );\n\n        if (response) {\n          // Mettre à jour la liste des employés\n          setEmployees((prevEmployees) =>\n            prevEmployees.filter((emp) => emp.id !== id)\n          );\n          return { success: true };\n        } else {\n          const errorMessage =\n            response?.message || \"Erreur lors de la suppression de l'employé\";\n          console.error(\"Erreur API:\", errorMessage);\n          return { success: false, error: errorMessage };\n        }\n      } catch (err) {\n        console.error(\"Erreur lors de la suppression de l'employé:\", err);\n        return { success: false, error: err.message || \"Erreur inconnue\" };\n      } finally {\n        setLoading(false);\n      }\n    },\n    [api]\n  );\n\n  /**\n   * Filtre les employés par statut\n   * @param {string|null} status - Le statut à filtrer (active, inactive, vacation, sick) ou null pour tous\n   * @returns {Array} - Les employés filtrés\n   */\n  const getEmployeesByStatus = useCallback(\n    (status) => {\n      if (!status || status === \"all\") return employees;\n      return employees.filter((employee) => employee.status === status);\n    },\n    [employees]\n  );\n\n  /**\n   * Récupère le solde d'heures d'un employé\n   */\n  const fetchEmployeeHourBalance = useCallback(\n    async (id) => {\n      try {\n        // Ajouter un délai aléatoire pour éviter les requêtes simultanées\n        const randomDelay = Math.floor(Math.random() * 200);\n        await new Promise((resolve) => setTimeout(resolve, randomDelay));\n\n        const response = await api.get(`/api/hour-balance/${id}`);\n\n        // Vérifier si la réponse contient hour_balance ou balance\n        if (\n          response &&\n          (response.hour_balance !== undefined ||\n            response.balance !== undefined)\n        ) {\n          const balance =\n            response.hour_balance !== undefined\n              ? response.hour_balance\n              : response.balance;\n\n          // Mettre à jour l'état local des employés avec le nouveau solde d'heures\n          setEmployees((prev) =>\n            prev.map((emp) =>\n              emp.id === id ? { ...emp, hour_balance: balance } : emp\n            )\n          );\n          return balance;\n        } else {\n          console.warn(\n            `Avertissement: Format de réponse inattendu pour l'employé #${id}`\n          );\n          return 0; // Retourner 0 par défaut\n        }\n      } catch (err) {\n        // Éviter de logger l'erreur complète pour ne pas surcharger la console\n        console.warn(\n          `Avertissement: Impossible de récupérer le solde d'heures pour l'employé #${id}`\n        );\n\n        // Ne pas mettre à jour l'état pour éviter des re-rendus en cascade\n        return 0; // Retourner 0 par défaut en cas d'erreur\n      }\n    },\n    [api, setEmployees]\n  );\n\n  /**\n   * Récupère le solde d'heures pour tous les employés\n   * Utilise une approche séquentielle pour éviter de surcharger le navigateur\n   */\n  const fetchAllEmployeesHourBalances = useCallback(async () => {\n    // Variable pour suivre si la fonction est déjà en cours d'exécution\n    if (window._isFetchingHourBalances) {\n      return;\n    }\n\n    try {\n      // Marquer comme en cours d'exécution\n      window._isFetchingHourBalances = true;\n\n      // Traiter les employés un par un au lieu de par lots\n      for (const employee of employees) {\n        try {\n          await fetchEmployeeHourBalance(employee.id);\n          // Attendre 300ms entre chaque requête\n          await new Promise((resolve) => setTimeout(resolve, 300));\n        } catch (error) {\n          // Ignorer les erreurs individuelles et continuer avec le prochain employé\n          console.warn(\n            `Erreur pour l'employé ${employee.id}, continuons avec le suivant`\n          );\n        }\n      }\n    } catch (err) {\n      console.error(\"Erreur lors de la récupération des soldes d'heures:\", err);\n    } finally {\n      // Marquer comme terminé\n      window._isFetchingHourBalances = false;\n    }\n  }, [employees, fetchEmployeeHourBalance]);\n\n  // Charger les employés au montage du composant\n  useEffect(() => {\n    let mounted = true;\n    let retryCount = 0;\n    const maxRetries = 3;\n\n    const loadEmployees = async () => {\n      if (retryCount >= maxRetries) {\n        if (mounted) {\n          setError(\n            \"Erreur lors du chargement des employés après plusieurs tentatives\"\n          );\n          setLoading(false);\n        }\n        return;\n      }\n\n      try {\n        const token = localStorage.getItem(\"token\");\n\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          setError(\"Vous devez être connecté pour accéder à ces données\");\n          setLoading(false);\n          return;\n        }\n\n        const data = await api.get(API_ENDPOINTS.EMPLOYEES.BASE);\n\n        if (mounted) {\n          if (Array.isArray(data)) {\n            setEmployees(data);\n            setError(null);\n          } else {\n            console.error(\"Format de données invalide:\", data);\n            setError(\"Format de données invalide\");\n          }\n          setLoading(false);\n        }\n      } catch (err) {\n        if (mounted) {\n          console.error(\"Erreur lors du chargement des employés:\", err);\n          setError(err.message || \"Erreur lors du chargement des employés\");\n\n          // Réessayer avec un délai exponentiel\n          retryCount++;\n          setTimeout(loadEmployees, 1000 * Math.pow(2, retryCount));\n        }\n      }\n    };\n\n    loadEmployees();\n\n    return () => {\n      mounted = false;\n    };\n  }, [api]);\n\n  // Charger les soldes d'heures après avoir chargé les employés\n  // Utiliser une référence pour suivre si l'effet a déjà été exécuté\n  const hourBalancesLoaded = useRef(false);\n\n  useEffect(() => {\n    // Ne charger les soldes d'heures que si les employés sont chargés et que l'effet n'a pas encore été exécuté\n    if (employees.length > 0 && !hourBalancesLoaded.current) {\n      // Marquer l'effet comme exécuté\n      hourBalancesLoaded.current = true;\n\n      // Ajouter un délai avant de charger les soldes d'heures\n      // pour s'assurer que le composant est complètement monté\n      const timer = setTimeout(() => {\n        fetchAllEmployeesHourBalances();\n      }, 1000);\n\n      return () => clearTimeout(timer);\n    }\n  }, [employees.length, fetchAllEmployeesHourBalances]);\n\n  return {\n    employees,\n    loading,\n    error,\n    fetchEmployees,\n    fetchEmployeeById,\n    createEmployee,\n    updateEmployee,\n    deleteEmployee,\n    getEmployeesByStatus,\n    fetchEmployeeHourBalance,\n    fetchAllEmployeesHourBalances,\n  };\n};\n\nexport default useEmployees;\n","// Constantes pour les employés\nexport const EMPLOYEE_DEPARTMENTS = [\n  { value: \"Marketing\", label: \"Marketing\" },\n  { value: \"Développement\", label: \"Développement\" },\n  { value: \"Design\", label: \"Design\" },\n  { value: \"Finance\", label: \"Finance\" },\n  { value: \"RH\", label: \"RH\" },\n];\n\nexport const EMPLOYEE_ROLES = [\n  { value: \"Manager\", label: \"Manager\" },\n  { value: \"Senior\", label: \"Senior\" },\n  { value: \"Junior\", label: \"Junior\" },\n  { value: \"Stagiaire\", label: \"Stagiaire\" },\n];\n\nexport const EMPLOYEE_STATUSES = [\n  { value: \"active\", label: \"Actif\" },\n  { value: \"pending\", label: \"En attente\" },\n  { value: \"inactive\", label: \"Inactif\" },\n];\n\n// Constantes pour les congés\nexport const VACATION_TYPES = [\n  { value: \"paid\", label: \"Congés payés\", color: \"#4CAF50\", defaultQuota: 25 },\n  { value: \"rtt\", label: \"RTT\", color: \"#2196F3\", defaultQuota: 11 },\n  {\n    value: \"unpaid\",\n    label: \"Congés sans solde\",\n    color: \"#9E9E9E\",\n    defaultQuota: null,\n  },\n  { value: \"sick\", label: \"Maladie\", color: \"#F44336\", defaultQuota: null },\n  {\n    value: \"exceptional\",\n    label: \"Absence exceptionnelle\",\n    color: \"#FF9800\",\n    defaultQuota: null,\n  },\n  {\n    value: \"recovery\",\n    label: \"Récupération\",\n    color: \"#9C27B0\",\n    defaultQuota: null,\n  },\n];\n\nexport const VACATION_STATUSES = [\n  { value: \"pending\", label: \"En attente\", color: \"#FFC107\" },\n  { value: \"approved\", label: \"Approuvé\", color: \"#4CAF50\" },\n  { value: \"rejected\", label: \"Refusé\", color: \"#F44336\" },\n];\n\n// Jours fériés en France pour 2024 (à mettre à jour chaque année)\nexport const FRENCH_HOLIDAYS_2024 = [\n  { date: \"2024-01-01\", name: \"Jour de l'an\" },\n  { date: \"2024-04-01\", name: \"Lundi de Pâques\" },\n  { date: \"2024-05-01\", name: \"Fête du Travail\" },\n  { date: \"2024-05-08\", name: \"Victoire 1945\" },\n  { date: \"2024-05-09\", name: \"Ascension\" },\n  { date: \"2024-05-20\", name: \"Lundi de Pentecôte\" },\n  { date: \"2024-07-14\", name: \"Fête Nationale\" },\n  { date: \"2024-08-15\", name: \"Assomption\" },\n  { date: \"2024-11-01\", name: \"Toussaint\" },\n  { date: \"2024-11-11\", name: \"Armistice 1918\" },\n  { date: \"2024-12-25\", name: \"Noël\" },\n];\n\n// Constantes pour les colonnes du tableau des employés\nexport const EMPLOYEE_TABLE_COLUMNS = [\n  {\n    id: \"name\",\n    header: \"Nom\",\n    accessor: (employee) => `${employee.first_name} ${employee.last_name}`,\n    sortable: true,\n  },\n  {\n    id: \"email\",\n    header: \"Email\",\n    accessor: (employee) => employee.email,\n    sortable: true,\n  },\n  {\n    id: \"department\",\n    header: \"Département\",\n    accessor: (employee) => employee.department,\n    sortable: true,\n  },\n  {\n    id: \"role\",\n    header: \"Rôle\",\n    accessor: (employee) => employee.role,\n    sortable: true,\n  },\n  {\n    id: \"status\",\n    header: \"Statut\",\n    accessor: (employee) => employee.status,\n    sortable: true,\n    type: \"status\",\n  },\n  {\n    id: \"hour_balance\",\n    header: \"Solde d'heures\",\n    accessor: (employee) => {\n      const balance = employee.hour_balance || 0;\n      const isPositive = balance >= 0;\n      return {\n        value: balance,\n        display: `${isPositive ? \"+\" : \"\"}${balance}h`,\n        isPositive,\n      };\n    },\n    sortable: true,\n    type: \"hour_balance\",\n  },\n  {\n    id: \"hire_date\",\n    header: \"Date d'embauche\",\n    accessor: (employee) => {\n      if (!employee.hire_date) return \"\";\n      const date = new Date(employee.hire_date);\n      return date.toLocaleDateString(\"fr-FR\");\n    },\n    sortable: true,\n    type: \"date\",\n  },\n];\n\n// URL de l'API\nexport const API_URL =\n  process.env.REACT_APP_API_URL || \"http://localhost:5001/api\";\n","import { useCallback, useMemo } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { API_URL } from \"../config/api\";\n\n/**\n * Hook personnalisé pour effectuer des appels API\n * @returns {Object} Méthodes pour effectuer des requêtes API\n */\nconst useApi = () => {\n  const handleResponse = useCallback(async (response) => {\n    try {\n      // Récupérer les en-têtes pour le débogage\n      const headers = {};\n      response.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      console.log(\"Réponse du serveur:\", {\n        url: response.url,\n        status: response.status,\n        statusText: response.statusText,\n        headers: headers,\n      });\n\n      // Vérifier si la réponse est au format JSON\n      const contentType = response.headers.get(\"content-type\");\n      const isJson = contentType && contentType.includes(\"application/json\");\n\n      // Récupérer le corps de la réponse\n      let data;\n      if (isJson) {\n        data = await response.json();\n        console.log(\"Données JSON reçues:\", data);\n      } else {\n        const text = await response.text();\n        console.warn(\"Réponse non-JSON reçue:\", text);\n        try {\n          // Essayer de parser le texte comme JSON\n          data = JSON.parse(text);\n          console.log(\"Texte parsé comme JSON:\", data);\n        } catch (e) {\n          data = { message: text };\n        }\n      }\n\n      // Gérer les différents codes de statut\n      if (response.ok) {\n        return data;\n      } else {\n        // Gérer les erreurs d'authentification (401, 403)\n        if (response.status === 401 || response.status === 403) {\n          console.error(\"Erreur d'authentification:\", data);\n          toast.error(\n            \"Session expirée ou accès non autorisé. Veuillez vous reconnecter.\"\n          );\n\n          // Supprimer le token et l'utilisateur du localStorage\n          localStorage.removeItem(\"token\");\n          localStorage.removeItem(\"user\");\n\n          // Rediriger vers la page de connexion après un délai\n          setTimeout(() => {\n            window.location.href = \"/login\";\n          }, 2000);\n        }\n\n        // Gérer les erreurs serveur (500)\n        if (response.status === 500) {\n          console.error(\"Erreur serveur:\", data);\n          console.error(\"URL:\", response.url);\n          console.error(\"Méthode:\", response.method);\n\n          // Journaliser plus de détails pour le débogage\n          if (data.error) {\n            console.error(\"Détails de l'erreur:\", data.error);\n          }\n          if (data.stack) {\n            console.error(\"Stack trace:\", data.stack);\n          }\n        }\n\n        // Construire un message d'erreur détaillé\n        const errorMessage =\n          data.message ||\n          data.error ||\n          response.statusText ||\n          \"Erreur inconnue\";\n        const error = new Error(errorMessage);\n        error.status = response.status;\n        error.response = { status: response.status, data };\n\n        throw error;\n      }\n    } catch (error) {\n      console.error(\"Erreur lors du traitement de la réponse:\", error);\n      throw error;\n    }\n  }, []);\n\n  const api = useMemo(() => {\n    const get = async (endpoint) => {\n      try {\n        console.log(`[API] GET ${endpoint}`);\n        const token = localStorage.getItem(\"token\");\n\n        if (!token) {\n          console.error(\n            \"Token d'authentification manquant pour la requête GET\"\n          );\n          toast.error(\"Vous devez être connecté pour accéder à ces données\");\n          setTimeout(() => {\n            window.location.href = \"/login\";\n          }, 2000);\n          return { ok: false, status: 401, data: [] };\n        }\n\n        // Ajouter un timeout pour éviter que les requêtes ne restent bloquées\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 secondes de timeout\n\n        try {\n          const response = await fetch(`${API_URL}${endpoint}`, {\n            method: \"GET\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n              Authorization: `Bearer ${token}`,\n            },\n            credentials: \"include\",\n            signal: controller.signal,\n          });\n\n          // Annuler le timeout\n          clearTimeout(timeoutId);\n\n          return await handleResponse(response);\n        } catch (fetchError) {\n          // Gérer spécifiquement les erreurs d'abort\n          if (fetchError.name === \"AbortError\") {\n            console.warn(`La requête ${endpoint} a été interrompue (timeout)`);\n            throw new Error(`Timeout de la requête après 5 secondes`);\n          }\n          throw fetchError;\n        }\n      } catch (error) {\n        console.error(`[API] GET ${endpoint} Error:`, error);\n\n        // Si l'erreur est liée à l'authentification, rediriger vers la page de connexion\n        if (error.status === 401 || error.status === 403) {\n          toast.error(\"Session expirée. Veuillez vous reconnecter.\");\n          setTimeout(() => {\n            window.location.href = \"/login\";\n          }, 2000);\n        } else {\n          // Ne pas afficher de toast pour les erreurs de timeout ou de réseau\n          // pour éviter de surcharger l'interface\n          if (\n            !error.message.includes(\"Timeout\") &&\n            !error.message.includes(\"fetch\")\n          ) {\n            toast.error(\n              error.message || \"Erreur lors de la récupération des données\"\n            );\n          }\n        }\n\n        throw error;\n      }\n    };\n\n    // Fonction utilitaire pour convertir camelCase en snake_case\n    const camelToSnakeCase = (str) => {\n      return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n    };\n\n    const post = async (endpoint, data) => {\n      try {\n        // Vérifier que les données sont valides\n        if (!data || typeof data !== \"object\") {\n          console.error(\"Données invalides pour la requête POST:\", data);\n          throw new Error(\"Données invalides pour la requête POST\");\n        }\n\n        // Convertir les données en snake_case pour le backend\n        const snakeCaseData = {};\n        for (const key in data) {\n          snakeCaseData[camelToSnakeCase(key)] = data[key];\n        }\n\n        // Récupérer le token d'authentification\n        const token = localStorage.getItem(\"token\");\n        if (!token) {\n          console.error(\"Token d'authentification manquant\");\n          throw new Error(\n            \"Vous devez être connecté pour effectuer cette action\"\n          );\n        }\n\n        // Configurer les en-têtes de la requête\n        const headers = {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        };\n\n        // Journaliser les détails de la requête (sans le token complet)\n        console.log(\"Détails de la requête POST:\", {\n          endpoint,\n          dataSize: JSON.stringify(snakeCaseData).length,\n          headers: { ...headers, Authorization: \"Bearer [MASQUÉ]\" },\n        });\n\n        // Effectuer la requête avec un timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondes de timeout\n\n        const response = await fetch(`${API_URL}${endpoint}`, {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(snakeCaseData),\n          signal: controller.signal,\n        });\n\n        // Annuler le timeout\n        clearTimeout(timeoutId);\n\n        // Traiter la réponse\n        return handleResponse(response);\n      } catch (error) {\n        // Gérer les erreurs spécifiques\n        if (error.name === \"AbortError\") {\n          console.error(\"La requête a été interrompue (timeout):\", error);\n          throw new Error(\n            \"La requête a pris trop de temps, veuillez réessayer\"\n          );\n        }\n\n        if (\n          error.message.includes(\"NetworkError\") ||\n          error.message.includes(\"Failed to fetch\")\n        ) {\n          console.error(\"Erreur réseau lors de la requête POST:\", error);\n          throw new Error(\n            \"Problème de connexion au serveur, veuillez vérifier votre connexion internet\"\n          );\n        }\n\n        // Journaliser et propager l'erreur\n        console.error(\"Erreur lors de la requête POST:\", error);\n        throw error;\n      }\n    };\n\n    const put = async (endpoint, data) => {\n      try {\n        console.log(`[API] PUT ${endpoint}`, data);\n        const token = localStorage.getItem(\"token\");\n\n        // S'assurer que les données sont sérialisables\n        const cleanData = JSON.parse(JSON.stringify(data));\n\n        // Convertir les données en snake_case pour le backend\n        const snakeCaseData = {};\n        for (const key in cleanData) {\n          snakeCaseData[camelToSnakeCase(key)] = cleanData[key];\n        }\n\n        const response = await fetch(`${API_URL}${endpoint}`, {\n          method: \"PUT\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: token ? `Bearer ${token}` : \"\",\n          },\n          body: JSON.stringify(snakeCaseData),\n        });\n\n        const result = await handleResponse(response);\n        console.log(`[API] PUT ${endpoint} Response:`, result);\n        return result;\n      } catch (error) {\n        console.error(`[API] PUT ${endpoint} Error:`, error);\n        return {\n          ok: false,\n          status: 0,\n          data: { message: error.message || \"Erreur lors de la requête PUT\" },\n          headers: new Headers(),\n        };\n      }\n    };\n\n    const del = async (endpoint) => {\n      try {\n        console.log(`[API] DELETE ${endpoint}`);\n        const token = localStorage.getItem(\"token\");\n        const response = await fetch(`${API_URL}${endpoint}`, {\n          method: \"DELETE\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: token ? `Bearer ${token}` : \"\",\n          },\n          credentials: \"include\",\n        });\n\n        const result = await handleResponse(response);\n        console.log(`[API] DELETE ${endpoint} Response:`, result);\n        return result;\n      } catch (error) {\n        console.error(`[API] DELETE ${endpoint} Error:`, error);\n        return {\n          ok: false,\n          status: 0,\n          data: {\n            message: error.message || \"Erreur lors de la requête DELETE\",\n          },\n          headers: new Headers(),\n        };\n      }\n    };\n\n    return {\n      get,\n      post,\n      put,\n      delete: del,\n    };\n  }, [handleResponse]);\n\n  return api;\n};\n\nexport default useApi;\n"],"names":["formatDate","date","formatStr","arguments","length","undefined","dateObj","Date","isNaN","getTime","console","error","format","locale","fr","formatDateForInput","getWeekStart","startOfWeek","weekStartsOn","getWeekEnd","endOfWeek","addWeeks","amount","addWeeksDate","getDaysOfWeek","weekStart","days","i","push","addDays","isWeekend","day","getDay","calculateHours","startDate","endDate","diffHours","Math","round","getDayName","short","dayIndex","isHoliday","holidays","FRENCH_HOLIDAYS_2024","d","formattedDate","getFullYear","String","getMonth","padStart","getDate","formatDateForAPI","some","holiday","isWorkingDay","getWorkingDaysCount","start","end","count","currentDate","setDate","useEmployees","employees","setEmployees","useState","loading","setLoading","setError","api","useApi","fetchEmployees","useCallback","async","response","get","API_ENDPOINTS","EMPLOYEES","BASE","_response$data","ok","Error","data","message","employeesData","Array","isArray","err","toast","fetchEmployeeById","BY_ID","id","_response$data2","createEmployee","post","employeeData","prevEmployees","includes","success","prev","employee","errorMessage","updateEmployee","put","map","emp","deleteEmployee","delete","filter","getEmployeesByStatus","status","fetchEmployeeHourBalance","randomDelay","floor","random","Promise","resolve","setTimeout","hour_balance","balance","warn","fetchAllEmployeesHourBalances","window","_isFetchingHourBalances","useEffect","mounted","retryCount","loadEmployees","localStorage","getItem","pow","hourBalancesLoaded","useRef","current","timer","clearTimeout","EMPLOYEE_STATUSES","value","label","VACATION_TYPES","color","defaultQuota","name","EMPLOYEE_TABLE_COLUMNS","header","accessor","first_name","last_name","sortable","email","department","role","type","isPositive","display","hire_date","toLocaleDateString","handleResponse","headers","forEach","key","log","url","statusText","contentType","json","text","JSON","parse","e","removeItem","location","href","method","stack","useMemo","camelToSnakeCase","str","replace","letter","toLowerCase","endpoint","token","controller","AbortController","timeoutId","abort","fetch","API_URL","Authorization","credentials","signal","fetchError","snakeCaseData","dataSize","stringify","body","cleanData","result","Headers"],"sourceRoot":""}